<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>ip(7) — Linux manual pages</title>
  <link rel="stylesheet" href="../stylesheet/manpages.css" type="text/css" />
  
  <link rel="home" href="../index.html" title="ip(7) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body onload="javascript:init()">
  

  <div class="refentry" title="ip(7) — Linux manual pages">
    <a id="ip.7" name="ip.7" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>ip — Linux IPv4 protocol implementation</p>
    </div>

    <div class="refsynopsisdiv" title="Synopsis">
      <h2>Synopsis</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
#include &lt;sys/socket.h&gt;

#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt; /* superset of previous */
</pre>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">tcp_socket = <b class="fsfunc">socket</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">AF_INET</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">SOCK_STREAM</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">0</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">udp_socket = <b class="fsfunc">socket</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">AF_INET</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">SOCK_DGRAM</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">0</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">raw_socket = <b class="fsfunc">socket</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">AF_INET</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">SOCK_RAW</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1"><var class="pdparam">protocol</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="DESCRIPTION">
      <a id="ip-7_sect1" name="ip-7_sect1" shape="rect"> </a>

      <h2>DESCRIPTION</h2>

      <p>Linux implements the Internet Protocol, version 4,
      described in RFC 791 and RFC 1122. <em class="replaceable"><code>ip</code></em> contains a level 2
      multicasting implementation conforming to RFC 1112. It also
      contains an IP router including a packet filter.</p>

      <p>The programming interface is BSD-sockets compatible. For
      more information on sockets, see <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a>.</p>

      <p>An IP socket is created by calling the <a class="link" href="../htmlman2/socket.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(2)</span></a> function as
      <code class="function">socket</code>(<em class="parameter"><code>AF_INET</code></em>, <em class="replaceable"><code>socket_type</code></em>, <em class="parameter"><code>protocol</code></em>). Valid socket types
      are <em class="parameter"><code>SOCK_STREAM</code></em> to
      open a <a class="link" href="../htmlman7/tcp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">tcp</span>(7)</span></a> socket, <em class="parameter"><code>SOCK_DGRAM</code></em> to open a <a class="link" href="../htmlman7/udp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">udp</span>(7)</span></a> socket, or
      <em class="parameter"><code>SOCK_RAW</code></em> to open a
      <a class="link" href="../htmlman7/raw.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">raw</span>(7)</span></a> socket to access the
      IP protocol directly. <em class="parameter"><code>protocol</code></em> is the IP protocol in
      the IP header to be received or sent. The only valid values
      for <em class="parameter"><code>protocol</code></em> are 0
      and <code class="constant">IPPROTO_TCP</code> for TCP
      sockets, and 0 and <code class="constant">IPPROTO_UDP</code>
      for UDP sockets. For <em class="parameter"><code>SOCK_RAW</code></em> you may specify a
      valid IANA IP protocol defined in RFC 1700 assigned
      numbers.</p>

      <p>When a process wants to receive new incoming packets or
      connections, it should bind a socket to a local interface
      address using <a class="link" href="../htmlman2/bind.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a>. Only one IP socket
      may be bound to any given local (address, port) pair. When
      <code class="constant">INADDR_ANY</code> is specified in the
      bind call, the socket will be bound to <em class="replaceable"><code>all</code></em> local interfaces. When
      <a class="link" href="../htmlman2/listen.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">listen</span>(2)</span></a> or <a class="link" href="../htmlman2/connect.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a> are called on an
      unbound socket, it is automatically bound to a random free
      port with the local address set to <code class="constant">INADDR_ANY</code>.</p>

      <p>A TCP local socket address that has been bound is
      unavailable for some time after closing, unless the
      <code class="constant">SO_REUSEADDR</code> flag has been set.
      Care should be taken when using this flag as it makes TCP
      less reliable.</p>

      <div class="refsect2" title="Address Format">
        <a id="ip-7_sect2" name="ip-7_sect2" shape="rect"> </a>

        <h3>Address Format</h3>

        <p>An IP socket address is defined as a combination of an
        IP interface address and a 16-bit port number. The basic IP
        protocol does not supply port numbers, they are implemented
        by higher level protocols like <a class="link" href="../htmlman7/udp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">udp</span>(7)</span></a> and <a class="link" href="../htmlman7/tcp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">tcp</span>(7)</span></a>. On raw sockets
        <em class="replaceable"><code>sin_port</code></em> is set
        to the IP protocol.</p>

        <div class="blockquote">
          <blockquote class="blockquote">
            <div class="structdef">
              <table style="border-collapse: collapse;">
                <colgroup span="1">
                  <col span="1" />
                  <col span="1" />
                  <col span="1" />
                  <col span="1" />
                  <col span="1" />
                </colgroup>

                <tbody>
                  <tr>
                    <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">
                    struct</td>

                    <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">sockaddr_in</span> {</td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">sa_family_t</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>sin_family</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* address family: AF_INET */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">in_port_t</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>sin_port</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* port in network byte order */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct in_addr</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>sin_addr</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* internet address */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>

                  <tr>
                    <td class="structsep" style="" colspan="5" align="left" rowspan="1"></td>
                  </tr>

                  <tr>
                    <td style="" colspan="5" align="left" rowspan="1">
                      <div class="literallayout">
                        
                        /* Internet address. */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td style="" colspan="5" rowspan="1"> </td>
                  </tr>

                  <tr>
                    <td class="structdefhdr2" style="" align="left" rowspan="1" colspan="1">struct</td>

                    <td class="structdefhdr2" style="" colspan="4" align="left" rowspan="1"><span class="structname">in_addr</span> {</td>
                  </tr>

                  <tr>
                    <td style="" rowspan="1" colspan="1"> </td>

                    <td style="" align="left" rowspan="1" colspan="1"><span class="type">uint32_t</span></td>

                    <td class="norightpad" style="" align="right" rowspan="1" colspan="1">
                     </td>

                    <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>s_addr</code></em>;</td>

                    <td style="" align="left" rowspan="1" colspan="1">
                      <div class="literallayout">
                        
                        /* address in network byte order */
                      </div>
                    </td>
                  </tr>

                  <tr>
                    <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </blockquote>
        </div>

        <p><em class="parameter"><code>sin_family</code></em> is
        always set to <em class="parameter"><code>AF_INET</code></em>. This is required; in
        Linux 2.2 most networking functions return <span class="errorname">EINVAL</span> when this setting is missing.
        <em class="parameter"><code>sin_port</code></em> contains
        the port in network byte order. The port numbers below 1024
        are called <span class="emphasis"><em>privileged
        ports</em></span> (or sometimes: <span class="emphasis"><em>reserved ports</em></span>). Only privileged
        processes (i.e., those having the <code class="constant">CAP_NET_BIND_SERVICE</code> capability) may
        <a class="link" href="../htmlman2/bind.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a> to these sockets.
        Note that the raw IPv4 protocol as such has no concept of a
        port, they are only implemented by higher protocols like
        <a class="link" href="../htmlman7/tcp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">tcp</span>(7)</span></a> and <a class="link" href="../htmlman7/udp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">udp</span>(7)</span></a>.</p>

        <p><em class="parameter"><code>sin_addr</code></em> is the
        IP host address. The <em class="parameter"><code>s_addr</code></em> member of <span class="emphasis"><em>struct in_addr</em></span> contains the host
        interface address in network byte order. <em class="replaceable"><code>in_addr</code></em> should be assigned
        one of the <em class="replaceable"><code>INADDR_*</code></em> values (e.g.,
        <code class="constant">INADDR_ANY</code>) or set using the
        <a class="link" href="../htmlman3/inet.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inet_aton</span>(3)</span></a>, <a class="link" href="../htmlman3/inet.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inet_addr</span>(3)</span></a>, <a class="link" href="../htmlman3/inet.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">inet_makeaddr</span>(3)</span></a> library
        functions or directly with the name resolver (see <a class="link" href="../htmlman3/gethostbyname.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">gethostbyname</span>(3)</span></a>).</p>

        <p>IPv4 addresses are divided into unicast, broadcast and
        multicast addresses. Unicast addresses specify a single
        interface of a host, broadcast addresses specify all hosts
        on a network and multicast addresses address all hosts in a
        multicast group. Datagrams to broadcast addresses can be
        only sent or received when the <code class="constant">SO_BROADCAST</code> socket flag is set. In the
        current implementation, connection-oriented sockets are
        only allowed to use unicast addresses.</p>

        <p>Note that the address and the port are always stored in
        network byte order. In particular, this means that you need
        to call <a class="link" href="../htmlman3/byteorder.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">htons</span>(3)</span></a> on the number
        that is assigned to a port. All address/port manipulation
        functions in the standard library work in network byte
        order.</p>

        <p>There are several special addresses: <code class="constant">INADDR_LOOPBACK</code> (127.0.0.1) always refers
        to the local host via the loopback device; <code class="constant">INADDR_ANY</code> (0.0.0.0) means any address
        for binding; <code class="constant">INADDR_BROADCAST</code>
        (255.255.255.255) means any host and has the same effect on
        bind as <code class="constant">INADDR_ANY</code> for
        historical reasons.</p>
      </div>

      <div class="refsect2" title="Socket Options">
        <a id="ip-7_sect3" name="ip-7_sect3" shape="rect"> </a>

        <h3>Socket Options</h3>

        <p>IP supports some protocol-specific socket options that
        can be set with <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a> and read
        with <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getsockopt</span>(2)</span></a>. The socket
        option level for IP is <code class="constant">IPPROTO_IP</code>. A boolean integer flag is
        zero when it is false, otherwise true.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">IP_ADD_MEMBERSHIP</code> (since Linux
            1.2)</span></dt>

            <dd>
              <p>Join a multicast group. Argument is an <em class="replaceable"><code>ip_mreqn</code></em>
              structure.</p>

              <div class="blockquote">
                <blockquote class="blockquote">
                  <div class="structdef">
                    <table style="border-collapse: collapse;">
                      <colgroup span="1">
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                      </colgroup>

                      <tbody>
                        <tr>
                          <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">struct</td>

                          <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">ip_mreqn</span> {</td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct in_addr</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>imr_multiaddr</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* IP multicast group<br />

                              address */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct in_addr</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>imr_address</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* IP address of local<br />

                              interface */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">int</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>imr_ifindex</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* interface index */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </blockquote>
              </div>

              <p><em class="parameter"><code>imr_multiaddr</code></em> contains
              the address of the multicast group the application
              wants to join or leave. It must be a valid multicast
              address (or <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a> fails
              with the error <span class="errorname">EINVAL</span>). <em class="parameter"><code>imr_address</code></em> is the
              address of the local interface with which the system
              should join the multicast group; if it is equal to
              <code class="constant">INADDR_ANY</code> an
              appropriate interface is chosen by the system.
              <em class="parameter"><code>imr_ifindex</code></em>
              is the interface index of the interface that should
              join/leave the <em class="parameter"><code>imr_multiaddr</code></em> group, or
              0 to indicate any interface.</p>

              <p>The <em class="replaceable"><code>ip_mreqn</code></em> structure is
              available only since Linux 2.2. For compatibility,
              the old <em class="replaceable"><code>ip_mreq</code></em> structure
              (present since Linux 1.2) is still supported; it
              differs from <em class="replaceable"><code>ip_mreqn</code></em> only by not
              including the <em class="parameter"><code>imr_ifindex</code></em> field. Only
              valid as a <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a>.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_DROP_MEMBERSHIP</code> (since Linux
            1.2)</span></dt>

            <dd>
              <p>Leave a multicast group. Argument is an <em class="replaceable"><code>ip_mreqn</code></em> or
              <em class="replaceable"><code>ip_mreq</code></em>
              structure similar to <code class="constant">IP_ADD_MEMBERSHIP</code>.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_FREEBIND</code> (since Linux
            2.4)</span></dt>

            <dd>
              <p>If enabled, this boolean option allows binding to
              an IP address that is nonlocal or does not (yet)
              exist. This permits listening on a socket, without
              requiring the underlying network interface or the
              specified dynamic IP address to be up at the time
              that the application is trying to bind to it. This
              option is the per-socket equivalent of the <em class="replaceable"><code>ip_nonlocal_bind</code></em>
              <code class="filename">/proc</code> interface
              described below.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_HDRINCL</code> (since Linux
            2.0)</span></dt>

            <dd>
              <p>If enabled, the user supplies an IP header in
              front of the user data. Only valid for <em class="parameter"><code>SOCK_RAW</code></em> sockets. See
              <a class="link" href="../htmlman7/raw.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">raw</span>(7)</span></a> for more
              information. When this flag is enabled the values set
              by <code class="constant">IP_OPTIONS</code>,
              <code class="constant">IP_TTL</code> and <code class="constant">IP_TOS</code> are ignored.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_MTU</code> (since Linux 2.2)</span></dt>

            <dd>
              <p>Retrieve the current known path MTU of the current
              socket. Only valid when the socket has been
              connected. Returns an integer. Only valid as a
              <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getsockopt</span>(2)</span></a>.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_MTU_DISCOVER</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Set or receive the Path MTU Discovery setting for
              a socket. When enabled, Linux will perform Path MTU
              Discovery as defined in RFC 1191 on this socket. The
              don't-fragment flag is set on all outgoing datagrams.
              The system-wide default is controlled by the
              <code class="filename">/proc/sys/net/ipv4/ip_no_pmtu_disc</code>
              file for <em class="parameter"><code>SOCK_STREAM</code></em> sockets,
              and disabled on all others. For non-<em class="parameter"><code>SOCK_STREAM</code></em> sockets, it
              is the user's responsibility to packetize the data in
              MTU sized chunks and to do the retransmits if
              necessary. The kernel will reject packets that are
              bigger than the known path MTU if this flag is set
              (with <span class="errorname">EMSGSIZE</span> ).</p>
            </dd>
          </dl>
        </div>

        <div class="informaltable">
          <table style="border-collapse: collapse;">
            <colgroup span="1">
              <col span="1" />
              <col span="1" />
            </colgroup>

            <tbody>
              <tr>
                <td style="" align="center" rowspan="1" colspan="1">Path MTU discovery
                flags</td>

                <td style="" align="left" rowspan="1" colspan="1">Meaning</td>
              </tr>

              <tr>
                <td style="" align="left" rowspan="1" colspan="1">IP_PMTUDISC_WANT</td>

                <td style="" align="left" rowspan="1" colspan="1">Use per-route
                settings.</td>
              </tr>

              <tr>
                <td style="" align="left" rowspan="1" colspan="1">IP_PMTUDISC_DONT</td>

                <td style="" align="left" rowspan="1" colspan="1">Never do Path MTU
                Discovery.</td>
              </tr>

              <tr>
                <td style="" align="left" rowspan="1" colspan="1">IP_PMTUDISC_DO</td>

                <td style="" align="left" rowspan="1" colspan="1">Always do Path MTU
                Discovery.</td>
              </tr>

              <tr>
                <td style="" align="left" rowspan="1" colspan="1">IP_PMTUDISC_PROBE</td>

                <td style="" align="left" rowspan="1" colspan="1">Set DF but ignore Path
                MTU.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <p>When PMTU discovery is enabled, the kernel automatically
        keeps track of the path MTU per destination host. When it
        is connected to a specific peer with <a class="link" href="../htmlman2/connect.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a>, the currently
        known path MTU can be retrieved conveniently using the
        <code class="constant">IP_MTU</code> socket option (e.g.,
        after a <span class="errorname">EMSGSIZE</span> error
        occurred). It may change over time. For connectionless
        sockets with many destinations, the new MTU for a given
        destination can also be accessed using the error queue (see
        <code class="constant">IP_RECVERR</code>). A new error will
        be queued for every incoming MTU update.</p>

        <p>While MTU discovery is in progress, initial packets from
        datagram sockets may be dropped. Applications using UDP
        should be aware of this and not take it into account for
        their packet retransmit strategy.</p>

        <p>To bootstrap the path MTU discovery process on
        unconnected sockets, it is possible to start with a big
        datagram size (up to 64K-headers bytes long) and let it
        shrink by updates of the path MTU.</p>

        <p>To get an initial estimate of the path MTU, connect a
        datagram socket to the destination address using <a class="link" href="../htmlman2/connect.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a> and retrieve
        the MTU by calling <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getsockopt</span>(2)</span></a> with the
        <code class="constant">IP_MTU</code> option.</p>

        <p>It is possible to implement RFC 4821 MTU probing with
        <em class="parameter"><code>SOCK_DGRAM</code></em> or
        <em class="parameter"><code>SOCK_RAW</code></em> sockets by
        setting a value of <code class="constant">IP_PMTUDISC_PROBE</code> (available since Linux
        2.6.22). This is also particularly useful for diagnostic
        tools such as <span class="citerefentry"><span class="refentrytitle">tracepath</span>(8)</span> that wish to
        deliberately send probe packets larger than the observed
        Path MTU.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">IP_MULTICAST_IF</code> (since Linux
            1.2)</span></dt>

            <dd>
              <p>Set the local device for a multicast socket.
              Argument is an <em class="replaceable"><code>ip_mreqn</code></em> or
              <em class="replaceable"><code>ip_mreq</code></em>
              structure similar to <code class="constant">IP_ADD_MEMBERSHIP</code>.</p>

              <p>When an invalid socket option is passed,
              <span class="errorname">ENOPROTOOPT</span> is
              returned.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_MULTICAST_LOOP</code> (since Linux
            1.2)</span></dt>

            <dd>
              <p>Set or read a boolean integer argument that
              determines whether sent multicast packets should be
              looped back to the local sockets.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_MULTICAST_TTL</code> (since Linux
            1.2)</span></dt>

            <dd>
              <p>Set or read the time-to-live value of outgoing
              multicast packets for this socket. It is very
              important for multicast packets to set the smallest
              TTL possible. The default is 1 which means that
              multicast packets don't leave the local network
              unless the user program explicitly requests it.
              Argument is an integer.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_NODEFRAG</code> (since Linux
            2.6.36)</span></dt>

            <dd>
              <p>If enabled (argument is nonzero), the reassembly
              of outgoing packets is disabled in the netfilter
              layer. This option is only valid for <em class="parameter"><code>SOCK_RAW</code></em> sockets. The
              argument is an integer.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_OPTIONS</code> (since Linux
            2.0)</span></dt>

            <dd>
              <p>Set or get the IP options to be sent with every
              packet from this socket. The arguments are a pointer
              to a memory buffer containing the options and the
              option length. The <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">setsockopt</span>(2)</span></a> call
              sets the IP options associated with a socket. The
              maximum option size for IPv4 is 40 bytes. See RFC 791
              for the allowed options. When the initial connection
              request packet for a <em class="parameter"><code>SOCK_STREAM</code></em> socket
              contains IP options, the IP options will be set
              automatically to the options from the initial packet
              with routing headers reversed. Incoming packets are
              not allowed to change options after the connection is
              established. The processing of all incoming source
              routing options is disabled by default and can be
              enabled by using the <em class="replaceable"><code>accept_source_route</code></em>
              <code class="filename">/proc</code> interface. Other
              options like timestamps are still handled. For
              datagram sockets, IP options can be only set by the
              local user. Calling <a class="link" href="../htmlman2/getsockopt.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">getsockopt</span>(2)</span></a> with
              <code class="constant">IP_OPTIONS</code> puts the
              current IP options used for sending into the supplied
              buffer.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_PKTINFO</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Pass an <code class="constant">IP_PKTINFO</code>
              ancillary message that contains a <em class="replaceable"><code>pktinfo</code></em> structure
              that supplies some information about the incoming
              packet. This only works for datagram oriented
              sockets. The argument is a flag that tells the socket
              whether the <code class="constant">IP_PKTINFO</code>
              message should be passed or not. The message itself
              can only be sent/retrieved as control message with a
              packet using <a class="link" href="../htmlman2/recv.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">recvmsg</span>(2)</span></a> or
              <a class="link" href="../htmlman2/send.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sendmsg</span>(2)</span></a>.</p>

              <div class="blockquote">
                <blockquote class="blockquote">
                  <div class="structdef">
                    <table style="border-collapse: collapse;">
                      <colgroup span="1">
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                        <col span="1" />
                      </colgroup>

                      <tbody>
                        <tr>
                          <td class="structdefhdr" style="" align="left" rowspan="1" colspan="1">struct</td>

                          <td class="structdefhdr" style="" colspan="4" align="left" rowspan="1"><span class="structname">in_pktinfo</span> {</td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">unsigned int</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>ipi_ifindex</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* Interface index */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct in_addr</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>ipi_spec_dst</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* Local address */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td style="" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><span class="type">struct in_addr</span></td>

                          <td class="norightpad" style="" align="right" rowspan="1" colspan="1"> </td>

                          <td style="" align="left" rowspan="1" colspan="1"><em class="structfield"><code>ipi_addr</code></em>;</td>

                          <td style="" align="left" rowspan="1" colspan="1">
                            <div class="literallayout">
                              
                              /* Header Destination<br />
                              address */
                            </div>
                          </td>
                        </tr>

                        <tr>
                          <td class="structdefftr" style="" colspan="5" align="left" rowspan="1">};</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </blockquote>
              </div>

              <p><em class="parameter"><code>ipi_ifindex</code></em> is the
              unique index of the interface the packet was received
              on. <em class="parameter"><code>ipi_spec_dst</code></em> is the
              local address of the packet and <em class="parameter"><code>ipi_addr</code></em> is the
              destination address in the packet header. If
              <code class="constant">IP_PKTINFO</code> is passed to
              <a class="link" href="../htmlman2/send.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sendmsg</span>(2)</span></a> and
              <em class="parameter"><code>ipi_spec_dst</code></em>
              is not zero, then it is used as the local source
              address for the routing table lookup and for setting
              up IP source route options. When <em class="parameter"><code>ipi_ifindex</code></em> is not
              zero, the primary local address of the interface
              specified by the index overwrites <em class="parameter"><code>ipi_spec_dst</code></em> for the
              routing table lookup.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RECVERR</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Enable extended reliable error message passing.
              When enabled on a datagram socket, all generated
              errors will be queued in a per-socket error queue.
              When the user receives an error from a socket
              operation, the errors can be received by calling
              <a class="link" href="../htmlman2/recv.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">recvmsg</span>(2)</span></a> with the
              <code class="constant">MSG_ERRQUEUE</code> flag set.
              The <em class="replaceable"><code>sock_extended_err</code></em>
              structure describing the error will be passed in an
              ancillary message with the type <code class="constant">IP_RECVERR</code> and the level
              <code class="constant">IPPROTO_IP</code>. This is
              useful for reliable error handling on unconnected
              sockets. The received data portion of the error queue
              contains the error packet.</p>

              <p>The <code class="constant">IP_RECVERR</code>
              control message contains a <em class="replaceable"><code>sock_extended_err</code></em>
              structure:</p>

              <div class="blockquote">
                <blockquote class="blockquote">
                  <div class="informalexample">
                    <pre class="programlisting" xml:space="preserve">
#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3

struct sock_extended_err {
    uint32_t ee_errno;   /* error number */
    uint8_t  ee_origin;  /* where the error originated */
    uint8_t  ee_type;    /* type */
    uint8_t  ee_code;    /* code */
    uint8_t  ee_pad;
    uint32_t ee_info;    /* additional information */
    uint32_t ee_data;    /* other data */
    /* More data may follow */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
</pre>
                  </div>
                </blockquote>
              </div>

              <p><em class="replaceable"><code>ee_errno</code></em>
              contains the <code class="varname">errno</code>
              number of the queued error. <em class="replaceable"><code>ee_origin</code></em> is the
              origin code of where the error originated. The other
              fields are protocol-specific. The macro <code class="constant">SO_EE_OFFENDER</code> returns a pointer to
              the address of the network object where the error
              originated from given a pointer to the ancillary
              message. If this address is not known, the <em class="replaceable"><code>sa_family</code></em> member of
              the <em class="replaceable"><code>sockaddr</code></em> contains
              <code class="constant">AF_UNSPEC</code> and the other
              fields of the <em class="replaceable"><code>sockaddr</code></em> are
              undefined.</p>

              <p>IP uses the <em class="replaceable"><code>sock_extended_err</code></em>
              structure as follows: <em class="replaceable"><code>ee_origin</code></em> is set to
              <code class="constant">SO_EE_ORIGIN_ICMP</code> for
              errors received as an ICMP packet, or <code class="constant">SO_EE_ORIGIN_LOCAL</code> for locally
              generated errors. Unknown values should be ignored.
              <em class="replaceable"><code>ee_type</code></em> and
              <em class="replaceable"><code>ee_code</code></em> are
              set from the type and code fields of the ICMP header.
              <em class="replaceable"><code>ee_info</code></em>
              contains the discovered MTU for <span class="errorname">EMSGSIZE</span> errors. The message also
              contains the <span class="emphasis"><em>sockaddr_in
              of the node</em></span> caused the error, which can
              be accessed with the <code class="constant">SO_EE_OFFENDER</code> macro. The
              <em class="parameter"><code>sin_family</code></em>
              field of the <code class="constant">SO_EE_OFFENDER</code> address is
              <code class="constant">AF_UNSPEC</code> when the
              source was unknown. When the error originated from
              the network, all IP options (<code class="constant">IP_OPTIONS</code>, <code class="constant">IP_TTL</code>, etc.) enabled on the socket
              and contained in the error packet are passed as
              control messages. The payload of the packet causing
              the error is returned as normal payload. Note that
              TCP has no error queue; <code class="constant">MSG_ERRQUEUE</code> is not permitted on
              <em class="parameter"><code>SOCK_STREAM</code></em>
              sockets. <code class="constant">IP_RECVERR</code> is
              valid for TCP, but all errors are returned by socket
              function return or <code class="constant">SO_ERROR</code> only.</p>

              <p>For raw sockets, <code class="constant">IP_RECVERR</code> enables passing of all
              received ICMP errors to the application, otherwise
              errors are only reported on connected sockets</p>

              <p>It sets or retrieves an integer boolean flag.
              <code class="constant">IP_RECVERR</code> defaults to
              off.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RECVOPTS</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Pass all incoming IP options to the user in a
              <code class="constant">IP_OPTIONS</code> control
              message. The routing header and other options are
              already filled in for the local host. Not supported
              for <em class="parameter"><code>SOCK_STREAM</code></em>
              sockets.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RECVORIGDSTADDR</code> (since Linux
            2.6.29)</span></dt>

            <dd>
              <p>This boolean option enables the <code class="constant">IP_ORIGDSTADDR</code> ancillary message in
              <a class="link" href="../htmlman2/recv.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">recvmsg</span>(2)</span></a>, in
              which the kernel returns the original destination
              address of the datagram being received. The ancillary
              message contains a <span class="emphasis"><em>struct
              sockaddr_in</em></span>.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RECVTOS</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>If enabled the <code class="constant">IP_TOS</code> ancillary message is passed
              with incoming packets. It contains a byte which
              specifies the Type of Service/Precedence field of the
              packet header. Expects a boolean integer flag.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RECVTTL</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>When this flag is set, pass a <code class="constant">IP_TTL</code> control message with the
              time to live field of the received packet as a byte.
              Not supported for <em class="parameter"><code>SOCK_STREAM</code></em>
              sockets.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_RETOPTS</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Identical to <code class="constant">IP_RECVOPTS</code>, but returns raw
              unprocessed options with timestamp and route record
              options not filled in for this hop.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_ROUTER_ALERT</code> (since Linux
            2.2)</span></dt>

            <dd>
              <p>Pass all to-be forwarded packets with the IP
              Router Alert option set to this socket. Only valid
              for raw sockets. This is useful, for instance, for
              user-space RSVP daemons. The tapped packets are not
              forwarded by the kernel; it is the user's
              responsibility to send them out again. Socket binding
              is ignored, such packets are only filtered by
              protocol. Expects an integer flag.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_TOS</code> (since Linux 1.0)</span></dt>

            <dd>
              <p>Set or receive the Type-Of-Service (TOS) field
              that is sent with every IP packet originating from
              this socket. It is used to prioritize packets on the
              network. TOS is a byte. There are some standard TOS
              flags defined: <code class="constant">IPTOS_LOWDELAY</code> to minimize delays
              for interactive traffic, <code class="constant">IPTOS_THROUGHPUT</code> to optimize
              throughput, <code class="constant">IPTOS_RELIABILITY</code> to optimize for
              reliability, <code class="constant">IPTOS_MINCOST</code> should be used for
              "filler data" where slow transmission doesn't matter.
              At most one of these TOS values can be specified.
              Other bits are invalid and shall be cleared. Linux
              sends <code class="constant">IPTOS_LOWDELAY</code>
              datagrams first by default, but the exact behavior
              depends on the configured queueing discipline. Some
              high priority levels may require superuser privileges
              (the <code class="constant">CAP_NET_ADMIN</code>
              capability). The priority can also be set in a
              protocol independent way by the (<code class="constant">SOL_SOCKET</code>, <code class="constant">SO_PRIORITY</code>) socket option (see
              <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a>).</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_TRANSPARENT</code> (since Linux
            2.6.24)</span></dt>

            <dd>
              <p>Setting this boolean option enables transparent
              proxying on this socket. This socket option allows
              the calling application to bind to a nonlocal IP
              address and operate both as a client and a server
              with the foreign address as the local endpoint. NOTE:
              this requires that routing be set up in a way that
              packets going to the foreign address are routed
              through the TProxy box. Enabling this socket option
              requires superuser privileges (the <code class="constant">CAP_NET_ADMIN</code> capability).</p>

              <p>TProxy redirection with the iptables TPROXY target
              also requires that this option be set on the
              redirected socket.</p>
            </dd>

            <dt><span class="term"><code class="constant">IP_TTL</code> (since Linux 1.0)</span></dt>

            <dd>
              <p>Set or retrieve the current time-to-live field
              that is used in every packet sent from this
              socket.</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="refsect2" title="/proc interfaces">
        <a id="ip-7_sect4" name="ip-7_sect4" shape="rect"> </a>

        <h3>/proc interfaces</h3>

        <p>The IP protocol supports a set of <code class="filename">/proc</code> interfaces to configure some global
        parameters. The parameters can be accessed by reading or
        writing files in the directory <code class="filename">/proc/sys/net/ipv4/</code>. Interfaces described
        as <em class="replaceable"><code>Boolean</code></em> take
        an integer value, with a nonzero value ("true") meaning
        that the corresponding option is enabled, and a zero value
        ("false") meaning that the option is disabled.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><em class="replaceable"><code>ip_always_defrag</code></em>
            (Boolean; since Linux 2.2.13)</span></dt>

            <dd>
              <p>[New with kernel 2.2.13; in earlier kernel
              versions this feature was controlled at compile time
              by the <code class="constant">CONFIG_IP_ALWAYS_DEFRAG</code> option;
              this option is not present in 2.4.x and later]</p>

              <p>When this boolean flag is enabled (not equal 0),
              incoming fragments (parts of IP packets that arose
              when some host between origin and destination decided
              that the packets were too large and cut them into
              pieces) will be reassembled (defragmented) before
              being processed, even if they are about to be
              forwarded.</p>

              <p>Only enable if running either a firewall that is
              the sole link to your network or a transparent proxy;
              never ever use it for a normal router or host.
              Otherwise fragmented communication can be disturbed
              if the fragments travel over different links.
              Defragmentation also has a large memory and CPU time
              cost.</p>

              <p>This is automagically turned on when masquerading
              or transparent proxying are configured.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_autoconfig</code></em> (since
            Linux 2.2 to 2.6.17)</span></dt>

            <dd>
              <p>Not documented.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_default_ttl</code></em>
            (integer; default: 64; since Linux 2.2)</span></dt>

            <dd>
              <p>Set the default time-to-live value of outgoing
              packets. This can be changed per socket with the
              <code class="constant">IP_TTL</code> option.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_dynaddr</code></em> (Boolean;
            default: disabled; since Linux 2.0.31)</span></dt>

            <dd>
              <p>Enable dynamic socket address and masquerading
              entry rewriting on interface address change. This is
              useful for dialup interface with changing IP
              addresses. 0 means no rewriting, 1 turns it on and 2
              enables verbose mode.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_forward</code></em> (Boolean;
            default: disabled; since Linux 1.2)</span></dt>

            <dd>
              <p>Enable IP forwarding with a boolean flag. IP
              forwarding can be also set on a per-interface
              basis.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_local_port_range</code></em>
            (since Linux 2.2)</span></dt>

            <dd>
              <p>Contains two integers that define the default
              local port range allocated to sockets. Allocation
              starts with the first number and ends with the second
              number. Note that these should not conflict with the
              ports used by masquerading (although the case is
              handled). Also arbitrary choices may cause problems
              with some firewall packet filters that make
              assumptions about the local ports in use. First
              number should be at least greater than 1024, or
              better, greater than 4096, to avoid clashes with well
              known ports and to minimize firewall problems.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_no_pmtu_disc</code></em>
            (Boolean; default: disabled; since Linux
            2.2)</span></dt>

            <dd>
              <p>If enabled, don't do Path MTU Discovery for TCP
              sockets by default. Path MTU discovery may fail if
              misconfigured firewalls (that drop all ICMP packets)
              or misconfigured interfaces (e.g., a point-to-point
              link where the both ends don't agree on the MTU) are
              on the path. It is better to fix the broken routers
              on the path than to turn off Path MTU Discovery
              globally, because not doing it incurs a high cost to
              the network.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip_nonlocal_bind</code></em>
            (Boolean; default: disabled; since Linux
            2.4)</span></dt>

            <dd>
              <p>If set, allows processes to <a class="link" href="../htmlman2/bind.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">bind</span>(2)</span></a> to nonlocal
              IP addresses, which can be quite useful, but may
              break some applications.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip6frag_time</code></em> (integer;
            default: 30)</span></dt>

            <dd>
              <p>Time in seconds to keep an IPv6 fragment in
              memory.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ip6frag_secret_interval</code></em>
            (integer; default: 600)</span></dt>

            <dd>
              <p>Regeneration interval (in seconds) of the hash
              secret (or lifetime for the hash secret) for IPv6
              fragments.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>ipfrag_high_thresh</code></em>
            (integer), <em class="replaceable"><code>ipfrag_low_thresh</code></em>
            (integer)</span></dt>

            <dd>
              <p>If the amount of queued IP fragments reaches
              <em class="replaceable"><code>ipfrag_high_thresh</code></em>,
              the queue is pruned down to <em class="replaceable"><code>ipfrag_low_thresh</code></em>.
              Contains an integer with the number of bytes.</p>
            </dd>

            <dt><span class="term"><em class="replaceable"><code>neigh/*</code></em></span></dt>

            <dd>
              <p>See <a class="link" href="../htmlman7/arp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">arp</span>(7)</span></a>.</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="refsect2" title="Ioctls">
        <a id="ip-7_sect5" name="ip-7_sect5" shape="rect"> </a>

        <h3>Ioctls</h3>

        <p>All ioctls described in <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a> apply to
        <em class="replaceable"><code>ip</code></em>.</p>

        <p>Ioctls to configure generic device parameters are
        described in <a class="link" href="../htmlman7/netdevice.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">netdevice</span>(7)</span></a>.</p>
      </div>
    </div>

    <div class="refsect1" title="ERRORS">
      <a id="ip-7_sect6" name="ip-7_sect6" shape="rect"> </a>

      <h2>ERRORS</h2>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><span class="errorname">EACCES</span></span></dt>

          <dd>
            <p>The user tried to execute an operation without the
            necessary permissions. These include: sending a packet
            to a broadcast address without having the <code class="constant">SO_BROADCAST</code> flag set; sending a
            packet via a <em class="replaceable"><code>prohibit</code></em> route;
            modifying firewall settings without superuser
            privileges (the <code class="constant">CAP_NET_ADMIN</code> capability); binding to
            a privileged port without superuser privileges (the
            <code class="constant">CAP_NET_BIND_SERVICE</code>
            capability).</p>
          </dd>

          <dt><span class="term"><span class="errorname">EADDRINUSE</span></span></dt>

          <dd>
            <p>Tried to bind to an address already in use.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EADDRNOTAVAIL</span></span></dt>

          <dd>
            <p>A nonexistent interface was requested or the
            requested source address was not local.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EAGAIN</span></span></dt>

          <dd>
            <p>Operation on a nonblocking socket would block.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EALREADY</span></span></dt>

          <dd>
            <p>An connection operation on a nonblocking socket is
            already in progress.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ECONNABORTED</span></span></dt>

          <dd>
            <p>A connection was closed during an <a class="link" href="../htmlman2/accept.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">accept</span>(2)</span></a>.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EHOSTUNREACH</span></span></dt>

          <dd>
            <p>No valid routing table entry matches the destination
            address. This error can be caused by a ICMP message
            from a remote router or for the local routing
            table.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EINVAL</span></span></dt>

          <dd>
            <p>Invalid argument passed. For send operations this
            can be caused by sending to a <em class="replaceable"><code>blackhole</code></em> route.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EISCONN</span></span></dt>

          <dd>
            <p><a class="link" href="../htmlman2/connect.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">connect</span>(2)</span></a> was called
            on an already connected socket.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EMSGSIZE</span></span></dt>

          <dd>
            <p>Datagram is bigger than an MTU on the path and it
            cannot be fragmented.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOBUFS</span>, <span class="errorname">ENOMEM</span></span></dt>

          <dd>
            <p>Not enough free memory. This often means that the
            memory allocation is limited by the socket buffer
            limits, not by the system memory, but this is not 100%
            consistent.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOENT</span></span></dt>

          <dd>
            <p><code class="constant">SIOCGSTAMP</code> was called
            on a socket where no packet arrived.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOPKG</span></span></dt>

          <dd>
            <p>A kernel subsystem was not configured.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOPROTOOPT</span> and <span class="errorname">EOPNOTSUPP</span></span></dt>

          <dd>
            <p>Invalid socket option passed.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ENOTCONN</span></span></dt>

          <dd>
            <p>The operation is only defined on a connected socket,
            but the socket wasn't connected.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EPERM</span></span></dt>

          <dd>
            <p>User doesn't have permission to set high priority,
            change configuration, or send signals to the requested
            process or group.</p>
          </dd>

          <dt><span class="term"><span class="errorname">EPIPE</span></span></dt>

          <dd>
            <p>The connection was unexpectedly closed or shut down
            by the other end.</p>
          </dd>

          <dt><span class="term"><span class="errorname">ESOCKTNOSUPPORT</span></span></dt>

          <dd>
            <p>The socket is not configured or an unknown socket
            type was requested.</p>
          </dd>
        </dl>
      </div>

      <p>Other errors may be generated by the overlaying protocols;
      see <a class="link" href="../htmlman7/tcp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">tcp</span>(7)</span></a>, <a class="link" href="../htmlman7/raw.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">raw</span>(7)</span></a>, <a class="link" href="../htmlman7/udp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">udp</span>(7)</span></a> and <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a>.</p>
    </div>

    <div class="refsect1" title="NOTES">
      <a id="ip-7_sect7" name="ip-7_sect7" shape="rect"> </a>

      <h2>NOTES</h2>

      <p><code class="constant">IP_FREEBIND</code>, <code class="constant">IP_MTU</code>, <code class="constant">IP_MTU_DISCOVER</code>, <code class="constant">IP_RECVORIGDSTADDR</code>, <code class="constant">IP_PKTINFO</code>, <code class="constant">IP_RECVERR</code>, <code class="constant">IP_ROUTER_ALERT</code>, and <code class="constant">IP_TRANSPARENT</code> are Linux-specific.</p>

      <p>Be very careful with the <code class="constant">SO_BROADCAST</code> option − it is not
      privileged in Linux. It is easy to overload the network with
      careless broadcasts. For new application protocols it is
      better to use a multicast group instead of broadcasting.
      Broadcasting is discouraged.</p>

      <p>Some other BSD sockets implementations provide
      <code class="constant">IP_RCVDSTADDR</code> and <code class="constant">IP_RECVIF</code> socket options to get the
      destination address and the interface of received datagrams.
      Linux has the more general <code class="constant">IP_PKTINFO</code> for the same task.</p>

      <p>Some BSD sockets implementations also provide an
      <code class="constant">IP_RECVTTL</code> option, but an
      ancillary message with type <code class="constant">IP_RECVTTL</code> is passed with the incoming
      packet. This is different from the <code class="constant">IP_TTL</code> option used in Linux.</p>

      <p>Using <code class="constant">SOL_IP</code> socket options
      level isn't portable, BSD-based stacks use <code class="constant">IPPROTO_IP</code> level.</p>

      <div class="refsect2" title="Compatibility">
        <a id="ip-7_sect8" name="ip-7_sect8" shape="rect"> </a>

        <h3>Compatibility</h3>

        <p>For compatibility with Linux 2.0, the obsolete
        <code class="function">socket</code>(<em class="parameter"><code>AF_INET</code></em>, <em class="parameter"><code>SOCK_PACKET</code></em>, <em class="parameter"><code>protocol</code></em>) syntax is still
        supported to open a <a class="link" href="../htmlman7/packet.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">packet</span>(7)</span></a> socket. This is
        deprecated and should be replaced by <code class="function">socket</code>(<em class="parameter"><code>AF_PACKET</code></em>, <em class="parameter"><code>SOCK_RAW</code></em>, <em class="parameter"><code>protocol</code></em>) instead. The main
        difference is the new <em class="replaceable"><code>sockaddr_ll</code></em> address
        structure for generic link layer information instead of the
        old <em class="replaceable"><code>sockaddr_pkt</code></em>.</p>
      </div>
    </div>

    <div class="refsect1" title="BUGS">
      <a id="ip-7_sect9" name="ip-7_sect9" shape="rect"> </a>

      <h2>BUGS</h2>

      <p>There are too many inconsistent error values.</p>

      <p>The ioctls to configure IP-specific interface options and
      ARP tables are not described.</p>

      <p>Some versions of glibc forget to declare <em class="replaceable"><code>in_pktinfo</code></em>. Workaround
      currently is to copy it into your program from this man
      page.</p>

      <p>Receiving the original destination address with
      <code class="constant">MSG_ERRQUEUE</code> in <em class="replaceable"><code>msg_name</code></em> by <a class="link" href="../htmlman2/recv.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">recvmsg</span>(2)</span></a> does not work in
      some 2.2 kernels.</p>
    </div>

    <div class="refsect1" title="SEE ALSO">
      <a id="ip-7_sect10" name="ip-7_sect10" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><a class="link" href="../htmlman2/recv.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">recvmsg</span>(2)</span></a>, <a class="link" href="../htmlman2/send.2.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">sendmsg</span>(2)</span></a>, <a class="link" href="../htmlman3/byteorder.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">byteorder</span>(3)</span></a>, <span class="citerefentry"><span class="refentrytitle">ipfw</span>(4)</span>, <a class="link" href="../htmlman7/capabilities.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">capabilities</span>(7)</span></a>, <a class="link" href="../htmlman7/netlink.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">netlink</span>(7)</span></a>, <a class="link" href="../htmlman7/raw.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">raw</span>(7)</span></a>, <a class="link" href="../htmlman7/socket.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">socket</span>(7)</span></a>, <a class="link" href="../htmlman7/tcp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">tcp</span>(7)</span></a>, <a class="link" href="../htmlman7/udp.7.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">udp</span>(7)</span></a></p>

      <p>RFC 791 for the original IP specification.</p>

      <p>RFC 1122 for the IPv4 host requirements.</p>

      <p>RFC 1812 for the IPv4 router requirements.</p>
    </div>

    <div class="colophon" title="COLOPHON">
      <a id="ip-7_sect11" name="ip-7_sect11" shape="rect"> </a>

      <h2>COLOPHON</h2>

      <p>This page is part of release 3.31 of the Linux <em class="replaceable"><code>man-pages</code></em> project. A
      description of the project, and information about reporting
      bugs, can be found at
      http://www.kernel.org/doc/man-pages/.</p>

      <div class="license">
        <table style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>

          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <div class="literallayout">
                  <br />
                    t<br />
                  Don't change the line above. it tells man that tbl is needed.<br />

                  This man page is Copyright (C) 1999 Andi Kleen &lt;ak<script type="text/javascript">document.write('@');</script><noscript>(@)</noscript>muc.de&gt;.<br />

                  Permission is granted to distribute possibly modified copies<br />

                  of this page provided the header is included verbatim,<br />

                  and in case of nontrivial modification author and date<br />

                  of the modification is added to the header.<br />

                  $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $<br />

                  <br />
                  FIXME: Document IP_MINTTL, added in Linux 2.6.34<br />
                  
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
