<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>pcreapi(3) — Linux manual pages</title>
  <link rel="stylesheet" href="../stylesheet/manpages.css" type="text/css" />
  
  <link rel="home" href="../index.html" title="pcreapi(3) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body onload="javascript:init()">
  

  <div class="refentry" title="pcreapi(3) — Linux manual pages">
    <a id="pcreapi.3" name="pcreapi.3" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>PCRE — Perl-compatible regular expressions</p>
    </div>

    <div class="refsect1" title="PCRE NATIVE API">
      <a id="pcreapi-3_sect1" name="pcreapi-3_sect1" shape="rect"> </a>

      <h2>PCRE NATIVE API</h2>

      <div class="funcsynopsis">
        <pre class="funcsynopsisinfo" xml:space="preserve">
#include &lt;pcre.h&gt;
</pre>

        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre *<b class="fsfunc">pcre_compile</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre *<b class="fsfunc">pcre_compile2</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">errorcodeptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_extra *<b class="fsfunc">pcre_study</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_exec</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_dfa_exec</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">workspace</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">wscount</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_copy_named_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_copy_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_named_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_stringnumber</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_stringtable_entries</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">first</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">last</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_substring_list</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char ***<var class="pdparam">listptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void <b class="fsfunc">pcre_free_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void <b class="fsfunc">pcre_free_substring_list</b>(</code></td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">const unsigned char
            *<b class="fsfunc">pcre_maketables</b>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_fullinfo</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_info</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">optptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int*<var class="pdparam">firstcharptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_refcount</b>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">adjust</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_config</b>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">char *<b class="fsfunc">pcre_version</b>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void <b class="fsfunc">*</b>(</code></td>

            <td rowspan="1" colspan="1">*pcre_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><b class="fsfunc">void</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void <b class="fsfunc">*</b>(</code></td>

            <td rowspan="1" colspan="1">*pcre_stack_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><b class="fsfunc">void</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_stack_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><b class="fsfunc">int</b>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_callout)(pcre_callout_block
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="PCRE API OVERVIEW">
      <a id="pcreapi-3_sect2" name="pcreapi-3_sect2" shape="rect"> </a>

      <h2>PCRE API OVERVIEW</h2>

      <p>PCRE has its own native API, which is described in this
      document. There are also some wrapper functions that
      correspond to the POSIX regular expression API. These are
      described in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a> documentation.
      Both of these APIs define a set of C function calls. A C++
      wrapper is distributed with PCRE. It is documented in the
      <a class="link" href="../htmlman3/pcrecpp.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecpp</span>(3)</span></a> page.</p>

      <p>The native API C function prototypes are defined in the
      header file <code class="filename">pcre.h</code>, and on Unix
      systems the library itself is called <em class="citetitle">libpcre</em>. It can normally be accessed by
      adding <code class="option">−lpcre</code> to the
      command for linking an application that uses PCRE. The header
      file defines the macros PCRE_MAJOR and PCRE_MINOR to contain
      the major and minor release numbers for the library.
      Applications can use these to include support for different
      releases of PCRE.</p>

      <p>In a Windows environment, if you want to statically link
      an application program against a non-dll <em class="replaceable"><code>pcre.a</code></em> file, you must define
      PCRE_STATIC before including <code class="filename">pcre.h</code> or <code class="filename">pcrecpp.h</code>, because otherwise the
      <code class="function">pcre_malloc</code>() and <code class="function">pcre_free</code>() exported functions will be
      declared <em class="replaceable"><code>__declspec(dllimport)</code></em>, with
      unwanted results.</p>

      <p>The functions <code class="function">pcre_compile</code>(), <code class="function">pcre_compile2</code>(), <code class="function">pcre_study</code>(), and <code class="function">pcre_exec</code>() are used for compiling and
      matching regular expressions in a Perl-compatible manner. A
      sample program that demonstrates the simplest way of using
      them is provided in the file called <code class="filename">pcredemo.c</code> in the PCRE source distribution.
      A listing of this program is given in the <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> documentation, and
      the <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a> documentation
      describes how to compile and run it.</p>

      <p>A second matching function, <code class="function">pcre_dfa_exec</code>(), which is not
      Perl-compatible, is also provided. This uses a different
      algorithm for the matching. The alternative algorithm finds
      all possible matches (at a given point in the subject), and
      scans the subject just once (unless there are lookbehind
      assertions). However, this algorithm does not return captured
      substrings. A description of the two matching algorithms and
      their advantages and disadvantages is given in the <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>In addition to the main compiling and matching functions,
      there are convenience functions for extracting captured
      substrings from a subject string that is matched by
      <code class="function">pcre_exec</code>(). They are:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <code class="function">pcre_copy_substring</code>()
 <code class="function">pcre_copy_named_substring</code>()
 <code class="function">pcre_get_substring</code>()
 <code class="function">pcre_get_named_substring</code>()
 <code class="function">pcre_get_substring_list</code>()
 <code class="function">pcre_get_stringnumber</code>()
 <code class="function">pcre_get_stringtable_entries</code>()
</pre>
      </div>

      <p><code class="function">pcre_free_substring</code>() and
      <code class="function">pcre_free_substring_list</code>() are
      also provided, to free the memory used for extracted
      strings.</p>

      <p>The function <code class="function">pcre_maketables</code>() is used to build a set of
      character tables in the current locale for passing to
      <code class="function">pcre_compile</code>(), <code class="function">pcre_exec</code>(), or <code class="function">pcre_dfa_exec</code>(). This is an optional
      facility that is provided for specialist use. Most commonly,
      no special tables are passed, in which case internal tables
      that are generated when PCRE is built are used.</p>

      <p>The function <code class="function">pcre_fullinfo</code>()
      is used to find out information about a compiled pattern;
      <code class="function">pcre_info</code>() is an obsolete
      version that returns only some of the available information,
      but is retained for backwards compatibility. The function
      <code class="function">pcre_version</code>() returns a
      pointer to a string containing the version of PCRE and its
      date of release.</p>

      <p>The function <code class="function">pcre_refcount</code>()
      maintains a reference count in a data block containing a
      compiled pattern. This is provided for the benefit of
      object-oriented applications.</p>

      <p>The global variables <code class="function">pcre_malloc</code> and <code class="function">pcre_free</code> initially contain the entry
      points of the standard <code class="function">malloc</code>()
      and <code class="function">free</code>() functions,
      respectively. PCRE calls the memory management functions via
      these variables, so a calling program can replace them if it
      wishes to intercept the calls. This should be done before
      calling any PCRE functions.</p>

      <p>The global variables <code class="function">pcre_stack_malloc</code> and <code class="function">pcre_stack_free</code> are also indirections to
      memory management functions. These special functions are used
      only when PCRE is compiled to use the heap for remembering
      data, instead of recursive function calls, when running the
      <code class="function">pcre_exec</code>() function. See the
      <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      for details of how to do this. It is a non-standard way of
      building PCRE, for use in environments that have limited
      stacks. Because of the greater use of memory management, it
      runs more slowly. Separate functions are provided so that
      special-purpose external code can be used for this case. When
      used, these functions are always called in a stack-like
      manner (last obtained, first freed), and always for memory
      blocks of the same size. There is a discussion about PCRE's
      stack usage in the <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>
      documentation.</p>

      <p>The global variable <code class="function">pcre_callout</code> initially contains NULL. It
      can be set by the caller to a "callout" function, which PCRE
      will then call at specified points during a matching
      operation. Details are given in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>
    </div>

    <div class="refsect1" title="NEWLINES">
      <a id="pcreapi-3_sect3" name="pcreapi-3_sect3" shape="rect"> </a>

      <h2>NEWLINES</h2>

      <p>PCRE supports five different conventions for indicating
      line breaks in strings: a single CR (carriage return)
      character, a single LF (linefeed) character, the
      two-character sequence CRLF, any of the three preceding, or
      any Unicode newline sequence. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029).</p>

      <p>Each of the first three conventions is used by at least
      one operating system as its standard newline sequence. When
      PCRE is built, a default can be specified. The default
      default is LF, which is the Unix standard. When PCRE is run,
      the default can be overridden, either when a pattern is
      compiled, or when it is matched.</p>

      <p>At compile time, the newline convention can be specified
      by the <em class="parameter"><code>options</code></em>
      argument of <code class="function">pcre_compile</code>(), or
      it can be specified by special text at the start of the
      pattern itself; this overrides any other settings. See the
      <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page for
      details of the special character sequences.</p>

      <p>In the PCRE documentation the word "newline" is used to
      mean "the character or pair of characters that indicate a
      line break". The choice of newline convention affects the
      handling of the dot, circumflex, and dollar metacharacters,
      the handling of #-comments in /x mode, and, when CRLF is a
      recognized line ending sequence, the match position
      advancement for a non-anchored pattern. There is more detail
      about this in the section on <code class="function">pcre_exec</code>() options below.</p>

      <p>The choice of newline convention does not affect the
      interpretation of the \n or \r escape sequences, nor does it
      affect what \R matches, which is controlled in a similar way,
      but by separate options.</p>
    </div>

    <div class="refsect1" title="MULTITHREADING">
      <a id="pcreapi-3_sect4" name="pcreapi-3_sect4" shape="rect"> </a>

      <h2>MULTITHREADING</h2>

      <p>The PCRE functions can be used in multi-threading
      applications, with the proviso that the memory management
      functions pointed to by <code class="function">pcre_malloc</code>, <code class="function">pcre_free</code>, <code class="function">pcre_stack_malloc</code>, and <code class="function">pcre_stack_free</code>, and the callout function
      pointed to by <code class="function">pcre_callout</code>, are
      shared by all threads.</p>

      <p>The compiled form of a regular expression is not altered
      during matching, so the same compiled pattern can safely be
      used by several threads at once.</p>
    </div>

    <div class="refsect1" title="SAVING PRECOMPILED PATTERNS FOR LATER USE">
      <a id="pcreapi-3_sect5" name="pcreapi-3_sect5" shape="rect"> </a>

      <h2>SAVING PRECOMPILED PATTERNS FOR LATER USE</h2>

      <p>The compiled form of a regular expression can be saved and
      re-used at a later time, possibly by a different program, and
      even on a host other than the one on which it was compiled.
      Details are given in the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation. However, compiling a regular expression with
      one version of PCRE for use with a different version is not
      guaranteed to work and may cause crashes.</p>
    </div>

    <div class="refsect1" title="CHECKING BUILD-TIME OPTIONS">
      <a id="pcreapi-3_sect6" name="pcreapi-3_sect6" shape="rect"> </a>

      <h2>CHECKING BUILD-TIME OPTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_config</b>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_config</code>()
      makes it possible for a PCRE client to discover which
      optional features have been compiled into the PCRE library.
      The <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      has more details about these optional features.</p>

      <p>The first argument for <code class="function">pcre_config</code>() is an integer, specifying
      which information is required; the second argument is a
      pointer to a variable into which the information is placed.
      The following information is available:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_CONFIG_UTF8</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if UTF-8
            support is available; otherwise it is set to zero.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_UNICODE_PROPERTIES</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            support for Unicode character properties is available;
            otherwise it is set to zero.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_NEWLINE</code></span></dt>

          <dd>
            <p>The output is an integer whose value specifies the
            default character sequence that is recognized as
            meaning "newline". The four values that are supported
            are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for
            ANYCRLF, and -1 for ANY. Though they are derived from
            ASCII, the same values are returned in EBCDIC
            environments. The default should normally correspond to
            the standard sequence for your operating system.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_BSR</code></span></dt>

          <dd>
            <p>The output is an integer whose value indicates what
            character sequences the \R escape sequence matches by
            default. A value of 0 means that \R matches any Unicode
            line ending sequence; a value of 1 means that \R
            matches only CR, LF, or CRLF. The default can be
            overridden when a pattern is compiled or matched.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_LINK_SIZE</code></span></dt>

          <dd>
            <p>The output is an integer that contains the number of
            bytes used for internal linkage in compiled regular
            expressions. The value is 2, 3, or 4. Larger values
            allow larger regular expressions to be compiled, at the
            expense of slower matching. The default value of 2 is
            sufficient for all but the most massive patterns, since
            it allows the compiled pattern to be up to 64K in
            size.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_POSIX_MALLOC_THRESHOLD</code></span></dt>

          <dd>
            <p>The output is an integer that contains the threshold
            above which the POSIX interface uses <code class="function">malloc</code>() for output vectors. Further
            details are given in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>
            documentation.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_MATCH_LIMIT</code></span></dt>

          <dd>
            <p>The output is a long integer that gives the default
            limit for the number of internal matching function
            calls in a <code class="function">pcre_exec</code>()
            execution. Further details are given with <code class="function">pcre_exec</code>() below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_MATCH_LIMIT_RECURSION</code></span></dt>

          <dd>
            <p>The output is a long integer that gives the default
            limit for the depth of recursion when calling the
            internal matching function in a <code class="function">pcre_exec</code>() execution. Further
            details are given with <code class="function">pcre_exec</code>() below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_STACKRECURSE</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            internal recursion when running <code class="function">pcre_exec</code>() is implemented by
            recursive function calls that use the stack to remember
            their state. This is the usual way that PCRE is
            compiled. The output is zero if PCRE was compiled to
            use blocks of data on the heap instead of recursive
            function calls. In this case, <code class="function">pcre_stack_malloc</code> and <code class="function">pcre_stack_free</code> are called to manage
            memory blocks on the heap, thus avoiding the use of the
            stack.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="COMPILING A PATTERN">
      <a id="pcreapi-3_sect7" name="pcreapi-3_sect7" shape="rect"> </a>

      <h2>COMPILING A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre *<b class="fsfunc">pcre_compile</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre *<b class="fsfunc">pcre_compile2</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">errorcodeptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>Either of the functions <code class="function">pcre_compile</code>() or <code class="function">pcre_compile2</code>() can be called to compile a
      pattern into an internal form. The only difference between
      the two interfaces is that <code class="function">pcre_compile2</code>() has an additional argument,
      <em class="parameter"><code>errorcodeptr</code></em>, via
      which a numerical error code can be returned. To avoid too
      much repetition, we refer just to <code class="function">pcre_compile</code>() below, but the information
      applies equally to <code class="function">pcre_compile2</code>().</p>

      <p>The pattern is a C string terminated by a binary zero, and
      is passed in the <em class="parameter"><code>pattern</code></em> argument. A pointer to
      a single block of memory that is obtained via <code class="function">pcre_malloc</code> is returned. This contains the
      compiled code and related data. The <code class="function">pcre</code> type is defined for the returned
      block; this is a typedef for a structure whose contents are
      not externally defined. It is up to the caller to free the
      memory (via <code class="function">pcre_free</code>) when it
      is no longer required.</p>

      <p>Although the compiled code of a PCRE regex is relocatable,
      that is, it does not depend on memory location, the complete
      <code class="function">pcre</code> data block is not fully
      relocatable, because it may contain a copy of the <em class="parameter"><code>tableptr</code></em> argument, which is an
      address (see below).</p>

      <p>The <em class="parameter"><code>options</code></em>
      argument contains various bit settings that affect the
      compilation. It should be zero if no options are required.
      The available options are described below. Some of them (in
      particular, those that are compatible with Perl, but some
      others as well) can also be set and unset from within the
      pattern (see the detailed description in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation). For those options that can be different in
      different parts of the pattern, the contents of the
      <em class="parameter"><code>options</code></em> argument
      specifies their settings at the start of compilation and
      execution. The PCRE_ANCHORED, PCRE_BSR_<em class="replaceable"><code>xxx</code></em>, PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>, PCRE_NO_UTF8_CHECK, and
      PCRE_NO_START_OPT options can be set at the time of matching
      as well as at compile time.</p>

      <p>If <em class="parameter"><code>errptr</code></em> is NULL,
      <code class="function">pcre_compile</code>() returns NULL
      immediately. Otherwise, if compilation of a pattern fails,
      <code class="function">pcre_compile</code>() returns NULL,
      and sets the variable pointed to by <em class="parameter"><code>errptr</code></em> to point to a textual
      error message. This is a static string that is part of the
      library. You must not try to free it. The offset from the
      start of the pattern to the byte that was being processed
      when the error was discovered is placed in the variable
      pointed to by <em class="parameter"><code>erroffset</code></em>, which must not be
      NULL. If it is, an immediate error is given. Some errors are
      not detected until checks are carried out when the whole
      pattern has been scanned; in this case the offset is set to
      the end of the pattern.</p>

      <p>Note that the offset is in bytes, not characters, even in
      UTF-8 mode. It may point into the middle of a UTF-8 character
      (for example, when PCRE_ERROR_BADUTF8 is returned for an
      invalid UTF-8 string).</p>

      <p>If <code class="function">pcre_compile2</code>() is used
      instead of <code class="function">pcre_compile</code>(), and
      the <em class="parameter"><code>errorcodeptr</code></em>
      argument is not NULL, a non-zero error code number is
      returned via this argument in the event of an error. This is
      in addition to the textual error message. Error codes and
      messages are listed below.</p>

      <p>If the final argument, <em class="parameter"><code>tableptr</code></em>, is NULL, PCRE uses a
      default set of character tables that are built when PCRE is
      compiled, using the default C locale. Otherwise, <em class="parameter"><code>tableptr</code></em> must be an address
      that is the result of a call to <code class="function">pcre_maketables</code>(). This value is stored
      with the compiled pattern, and used again by <code class="function">pcre_exec</code>(), unless another table pointer
      is passed to it. For more discussion, see the section on
      locale support below.</p>

      <p>This code fragment shows a typical straightforward call to
      <code class="function">pcre_compile</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre *re;
 const char *error;
 int erroffset;
 re = pcre_compile(
   "^A.*Z",          /* the pattern */
   0,                /* default options */
   &amp;error,           /* for error message */
   &amp;erroffset,       /* for error offset */
   NULL);            /* use default character tables */
</pre>
      </div>

      <p>The following names for option bits are defined in the
      <code class="filename">pcre.h</code> header file:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_ANCHORED</code></span></dt>

          <dd>
            <p>If this bit is set, the pattern is forced to be
            "anchored", that is, it is constrained to match only at
            the first matching point in the string that is being
            searched (the "subject string"). This effect can also
            be achieved by appropriate constructs in the pattern
            itself, which is the only way to do it in Perl.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_AUTO_CALLOUT</code></span></dt>

          <dd>
            <p>If this bit is set, <code class="function">pcre_compile</code>() automatically inserts
            callout items, all with number 255, before each pattern
            item. For discussion of the callout facility, see the
            <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
            documentation.</p>

            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
            </div>

            <p>These options (which are mutually exclusive) control
            what the \R escape sequence matches. The choice is
            either to match only CR, LF, or CRLF, or to match any
            Unicode newline sequence. The default is specified when
            PCRE is built. It can be overridden from within the
            pattern, or by setting an option when a compiled
            pattern is matched.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CASELESS</code></span></dt>

          <dd>
            <p>If this bit is set, letters in the pattern match
            both upper and lower case letters. It is equivalent to
            Perl's /i option, and it can be changed within a
            pattern by a (?i) option setting. In UTF-8 mode, PCRE
            always understands the concept of case for characters
            whose values are less than 128, so caseless matching is
            always possible. For characters with higher values, the
            concept of case is supported if PCRE is compiled with
            Unicode property support, but not otherwise. If you
            want to use caseless matching for characters 128 and
            above, you must ensure that PCRE is compiled with
            Unicode property support as well as with UTF-8
            support.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DOLLAR_ENDONLY</code></span></dt>

          <dd>
            <p>If this bit is set, a dollar metacharacter in the
            pattern matches only at the end of the subject string.
            Without this option, a dollar also matches immediately
            before a newline at the end of the string (but not
            before any other newlines). The PCRE_DOLLAR_ENDONLY
            option is ignored if PCRE_MULTILINE is set. There is no
            equivalent to this option in Perl, and no way to set it
            within a pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DOTALL</code></span></dt>

          <dd>
            <p>If this bit is set, a dot metacharacter in the
            pattern matches a character of any value, including one
            that indicates a newline. However, it only ever matches
            one character, even if newlines are coded as CRLF.
            Without this option, a dot does not match when the
            current position is at a newline. This option is
            equivalent to Perl's /s option, and it can be changed
            within a pattern by a (?s) option setting. A negative
            class such as [^a] always matches newline characters,
            independent of the setting of this option.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DUPNAMES</code></span></dt>

          <dd>
            <p>If this bit is set, names used to identify capturing
            subpatterns need not be unique. This can be helpful for
            certain types of pattern when it is known that only one
            instance of the named subpattern can ever be matched.
            There are more details of named subpatterns below; see
            also the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
            documentation.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_EXTENDED</code></span></dt>

          <dd>
            <p>If this bit is set, whitespace data characters in
            the pattern are totally ignored except when escaped or
            inside a character class. Whitespace does not include
            the VT character (code 11). In addition, characters
            between an unescaped # outside a character class and
            the next newline, inclusive, are also ignored. This is
            equivalent to Perl's /x option, and it can be changed
            within a pattern by a (?x) option setting.</p>
          </dd>
        </dl>
      </div>

      <p>Which characters are interpreted as newlines is controlled
      by the options passed to <code class="function">pcre_compile</code>() or by a special sequence at
      the start of the pattern, as described in the section
      entitled "Newline conventions" in the <code class="function">pcrepattern</code> documentation. Note that the
      end of this type of comment is a literal newline sequence in
      the pattern; escape sequences that happen to represent a
      newline do not count.</p>

      <p>This option makes it possible to include comments inside
      complicated patterns. Note, however, that this applies only
      to data characters. Whitespace characters may never appear
      within special character sequences in a pattern, for example
      within the sequence (?( that introduces a conditional
      subpattern.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_EXTRA</code></span></dt>

          <dd>
            <p>This option was invented in order to turn on
            additional functionality of PCRE that is incompatible
            with Perl, but it is currently of very little use. When
            set, any backslash in a pattern that is followed by a
            letter that has no special meaning causes an error,
            thus reserving these combinations for future expansion.
            By default, as in Perl, a backslash followed by a
            letter with no special meaning is treated as a literal.
            (Perl can, however, be persuaded to give an error for
            this, by running it with the -w option.) There are at
            present no other features controlled by this option. It
            can also be set by a (?X) option setting within a
            pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_FIRSTLINE</code></span></dt>

          <dd>
            <p>If this option is set, an unanchored pattern is
            required to match before or at the first newline in the
            subject string, though the matched text may continue
            over the newline.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_JAVASCRIPT_COMPAT</code></span></dt>

          <dd>
            <p>If this option is set, PCRE's behaviour is changed
            in some ways so that it is compatible with JavaScript
            rather than Perl. The changes are as follows:</p>
          </dd>
        </dl>
      </div>

      <p>(1) A lone closing square bracket in a pattern causes a
      compile-time error, because this is illegal in JavaScript (by
      default it is treated as a data character). Thus, the pattern
      AB]CD becomes illegal when this option is set.</p>

      <p>(2) At run time, a back reference to an unset subpattern
      group matches an empty string (by default this causes the
      current matching alternative to fail). A pattern such as
      (\1)(a) succeeds when this option is set (assuming it can
      find an "a" in the subject), whereas it fails by default, for
      Perl compatibility.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_MULTILINE</code></span></dt>

          <dd>
            <p>By default, PCRE treats the subject string as
            consisting of a single line of characters (even if it
            actually contains newlines). The "start of line"
            metacharacter (^) matches only at the start of the
            string, while the "end of line" metacharacter ($)
            matches only at the end of the string, or before a
            terminating newline (unless PCRE_DOLLAR_ENDONLY is
            set). This is the same as Perl.</p>
          </dd>
        </dl>
      </div>

      <p>When PCRE_MULTILINE it is set, the "start of line" and
      "end of line" constructs match immediately following or
      immediately before internal newlines in the subject string,
      respectively, as well as at the very start and end. This is
      equivalent to Perl's /m option, and it can be changed within
      a pattern by a (?m) option setting. If there are no newlines
      in a subject string, or no occurrences of ^ or $ in a
      pattern, setting PCRE_MULTILINE has no effect.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
      </div>

      <p>These options override the default newline definition that
      was chosen when PCRE was built. Setting the first or the
      second specifies that a newline is indicated by a single
      character (CR or LF, respectively). Setting PCRE_NEWLINE_CRLF
      specifies that a newline is indicated by the two-character
      CRLF sequence. Setting PCRE_NEWLINE_ANYCRLF specifies that
      any of the three preceding sequences should be recognized.
      Setting PCRE_NEWLINE_ANY specifies that any Unicode newline
      sequence should be recognized. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029). The last two are recognized only in UTF-8
      mode.</p>

      <p>The newline setting in the options word uses three bits
      that are treated as a number, giving eight possibilities.
      Currently only six are used (default plus the five values
      above). This means that if you set more than one newline
      option, the combination may or may not be sensible. For
      example, PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent
      to PCRE_NEWLINE_CRLF, but other combinations may yield unused
      numbers and cause an error.</p>

      <p>The only time that a line break in a pattern is specially
      recognized when compiling is when PCRE_EXTENDED is set. CR
      and LF are whitespace characters, and so are ignored in this
      mode. Also, an unescaped # outside a character class
      indicates a comment that lasts until after the next line
      break sequence. In other circumstances, line break sequences
      in patterns are treated as literal data.</p>

      <p>The newline option that is set at compile time becomes the
      default that is used for <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), but it can be
      overridden.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_NO_AUTO_CAPTURE</code></span></dt>

          <dd>
            <p>If this option is set, it disables the use of
            numbered capturing parentheses in the pattern. Any
            opening parenthesis that is not followed by ? behaves
            as if it were followed by ?: but named parentheses can
            still be used for capturing (and they acquire numbers
            in the usual way). There is no equivalent of this
            option in Perl.</p>
          </dd>

          <dt><span class="term"><code class="constant">NO_START_OPTIMIZE</code></span></dt>

          <dd>
            <p>This is an option that acts at matching time; that
            is, it is really an option for <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). If it is set at
            compile time, it is remembered with the compiled
            pattern and assumed at matching time. For details see
            the discussion of PCRE_NO_START_OPTIMIZE below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UCP</code></span></dt>

          <dd>
            <p>This option changes the way PCRE processes \B, \b,
            \D, \d, \S, \s, \W, \w, and some of the POSIX character
            classes. By default, only ASCII characters are
            recognized, but if PCRE_UCP is set, Unicode properties
            are used instead to classify characters. More details
            are given in the section on generic character types in
            the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page.
            If you set PCRE_UCP, matching one of the items it
            affects takes much longer. The option is available only
            if PCRE has been compiled with Unicode property
            support.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UNGREEDY</code></span></dt>

          <dd>
            <p>This option inverts the "greediness" of the
            quantifiers so that they are not greedy by default, but
            become greedy if followed by "?". It is not compatible
            with Perl. It can also be set by a (?U) option setting
            within the pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UTF8</code></span></dt>

          <dd>
            <p>This option causes PCRE to regard both the pattern
            and the subject as strings of UTF-8 characters instead
            of single-byte character strings. However, it is
            available only when PCRE is built to include UTF-8
            support. If not, the use of this option provokes an
            error. Details of how this option changes the behaviour
            of PCRE are given in the section on UTF-8 support in
            the main <a class="link" href="../htmlman3/pcre.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre</span>(3)</span></a> page.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_NO_UTF8_CHECK</code></span></dt>

          <dd>
            <p>When PCRE_UTF8 is set, the validity of the pattern
            as a UTF-8 string is automatically checked. There is a
            discussion about the validity of UTF-8 strings in the
            main <a class="link" href="../htmlman3/pcre.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre</span>(3)</span></a> page. If an
            invalid UTF-8 sequence of bytes is found, <code class="function">pcre_compile</code>() returns an error. If
            you already know that your pattern is valid, and you
            want to skip this check for performance reasons, you
            can set the PCRE_NO_UTF8_CHECK option. When it is set,
            the effect of passing an invalid UTF-8 string as a
            pattern is undefined. It may cause your program to
            crash. Note that this option can also be passed to
            <code class="function">pcre_exec</code>() and
            <code class="function">pcre_dfa_exec</code>(), to
            suppress the UTF-8 validity checking of subject
            strings.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="COMPILATION ERROR CODES">
      <a id="pcreapi-3_sect8" name="pcreapi-3_sect8" shape="rect"> </a>

      <h2>COMPILATION ERROR CODES</h2>

      <p>The following table lists the error codes than may be
      returned by <code class="function">pcre_compile2</code>(),
      along with the error messages that may be returned by both
      compiling functions. As PCRE has developed, some error codes
      have fallen out of use. To avoid confusion, they have not
      been re-used.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
  0  no error
  1  \ at end of pattern
  2  \c at end of pattern
  3  unrecognized character follows \
  4  numbers out of order in {} quantifier
  5  number too big in {} quantifier
  6  missing terminating ] for character class
  7  invalid escape sequence in character class
  8  range out of order in character class
  9  nothing to repeat
 10  [this code is not in use]
 11  internal error: unexpected repeat
 12  unrecognized character after (? or (?-
 13  POSIX named classes are supported only within a class
 14  missing )
 15  reference to non-existent subpattern
 16  erroffset passed as NULL
 17  unknown option bit(s) set
 18  missing ) after comment
 19  [this code is not in use]
 20  regular expression is too large
 21  failed to get memory
 22  unmatched parentheses
 23  internal error: code overflow
 24  unrecognized character after (?&lt;
 25  lookbehind assertion is not fixed length
 26  malformed number or name after (?(
 27  conditional group contains more than two branches
 28  assertion expected after (?(
 29  (?R or (?[+-]digits must be followed by )
 30  unknown POSIX class name
 31  POSIX collating elements are not supported
 32  this version of PCRE is not compiled with PCRE_UTF8 support
 33  [this code is not in use]
 34  character value in \x{...} sequence is too large
 35  invalid condition (?(0)
 36  \C not allowed in lookbehind assertion
 37  PCRE does not support \L, \l, \N, \U, or \u
 38  number after (?C is &gt; 255
 39  closing ) for (?C expected
 40  recursive call could loop indefinitely
 41  unrecognized character after (?P
 42  syntax error in subpattern name (missing terminator)
 43  two named subpatterns have the same name
 44  invalid UTF-8 string
 45  support for \P, \p, and \X has not been compiled
 46  malformed \P or \p sequence
 47  unknown property name after \P or \p
 48  subpattern name is too long (maximum 32 characters)
 49  too many named subpatterns (maximum 10000)
 50  [this code is not in use]
 51  octal value is greater than \377 (not in UTF-8 mode)
 52  internal error: overran compiling workspace
 53  internal error: previously-checked referenced subpattern
       not found
 54  DEFINE group contains more than one branch
 55  repeating a DEFINE group is not allowed
 56  inconsistent NEWLINE options
 57  \g is not followed by a braced, angle-bracketed, or quoted
       name/number or by a plain number
 58  a numbered reference must not be zero
 59  an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)
 60  (*VERB) not recognized
 61  number is too big
 62  subpattern name expected
 63  digit expected after (?+
 64  ] is an invalid data character in JavaScript compatibility mode
 65  different names for subpatterns of the same number are
       not allowed
 66  (*MARK) must have an argument
 67  this version of PCRE is not compiled with PCRE_UCP support
</pre>
      </div>

      <p>The numbers 32 and 10000 in errors 48 and 49 are defaults;
      different values may be used if the limits were changed when
      PCRE was built.</p>
    </div>

    <div class="refsect1" title="STUDYING A PATTERN">
      <a id="pcreapi-3_sect9" name="pcreapi-3_sect9" shape="rect"> </a>

      <h2>STUDYING A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_extra *<b class="fsfunc">pcre_study</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int optionsconst char **<var class="pdparam">errptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>If a compiled pattern is going to be used several times,
      it is worth spending more time analyzing it in order to speed
      up the time taken for matching. The function <code class="function">pcre_study</code>() takes a pointer to a compiled
      pattern as its first argument. If studying the pattern
      produces additional information that will help speed up
      matching, <code class="function">pcre_study</code>() returns
      a pointer to a <span class="type">pcre_extra</span> block, in
      which the <em class="parameter"><code>study_data</code></em>
      field points to the results of the study.</p>

      <p>The returned value from <code class="function">pcre_study</code>() can be passed directly to
      <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). However, a <span class="type">pcre_extra</span> block also contains other fields
      that can be set by the caller before the block is passed;
      these are described below in the section on matching a
      pattern.</p>

      <p>If studying the pattern does not produce any useful
      information, <code class="function">pcre_study</code>()
      returns NULL. In that circumstance, if the calling program
      wants to pass any of the other fields to <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(), it must set up its own
      <span class="type">pcre_extra</span> block.</p>

      <p>The second argument of <code class="function">pcre_study</code>() contains option bits. At
      present, no options are defined, and this argument should
      always be zero.</p>

      <p>The third argument for <code class="function">pcre_study</code>() is a pointer for an error
      message. If studying succeeds (even if no data is returned),
      the variable it points to is set to NULL. Otherwise it is set
      to point to a textual error message. This is a static string
      that is part of the library. You must not try to free it. You
      should test the error pointer for NULL after calling
      <code class="function">pcre_study</code>(), to be sure that
      it has run successfully.</p>

      <p>This is a typical call to <code class="function">pcre_study</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre_extra *pe;
 pe = pcre_study(
   re,             /* result of pcre_compile() */
   0,              /* no options exist */
   &amp;error);        /* set to NULL or points to a message */
</pre>
      </div>

      <p>Studying a pattern does two things: first, a lower bound
      for the length of subject string that is needed to match the
      pattern is computed. This does not mean that there are any
      strings of that length that match, but it does guarantee that
      no shorter strings match. The value is used by <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>() to avoid wasting time by
      trying to match strings that are shorter than the lower
      bound. You can find out the value in a calling program via
      the <code class="function">pcre_fullinfo</code>()
      function.</p>

      <p>Studying a pattern is also useful for non-anchored
      patterns that do not have a single fixed starting character.
      A bitmap of possible starting bytes is created. This speeds
      up finding a position in the subject at which to start
      matching.</p>

      <p>The two optimizations just described can be disabled by
      setting the PCRE_NO_START_OPTIMIZE option when calling
      <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). You might want to do this
      if your pattern contains callouts or (*MARK), and you want to
      make use of these facilities in cases where matching fails.
      See the discussion of PCRE_NO_START_OPTIMIZE below.</p>
    </div>

    <div class="refsect1" title="LOCALE SUPPORT">
      <a id="pcreapi-3_sect10" name="pcreapi-3_sect10" shape="rect"> </a>

      <h2>LOCALE SUPPORT</h2>

      <p>PCRE handles caseless matching, and determines whether
      characters are letters, digits, or whatever, by reference to
      a set of tables, indexed by character value. When running in
      UTF-8 mode, this applies only to characters with codes less
      than 128. By default, higher-valued codes never match escapes
      such as \w or \d, but they can be tested with \p if PCRE is
      built with Unicode character property support. Alternatively,
      the PCRE_UCP option can be set at compile time; this causes
      \w and friends to use Unicode property support instead of
      built-in tables. The use of locales with Unicode is
      discouraged. If you are handling characters with codes
      greater than 128, you should either use UTF-8 and Unicode, or
      use locales, but not try to mix the two.</p>

      <p>PCRE contains an internal set of tables that are used when
      the final argument of <code class="function">pcre_compile</code>() is NULL. These are
      sufficient for many applications. Normally, the internal
      tables recognize only ASCII characters. However, when PCRE is
      built, it is possible to cause the internal tables to be
      rebuilt in the default "C" locale of the local system, which
      may cause them to be different.</p>

      <p>The internal tables can always be overridden by tables
      supplied by the application that calls PCRE. These may be
      created in a different locale from the default. As more and
      more applications change to using Unicode, the need for this
      locale support is expected to die away.</p>

      <p>External tables are built by calling the <code class="function">pcre_maketables</code>() function, which has no
      arguments, in the relevant locale. The result can then be
      passed to <code class="function">pcre_compile</code>() or
      <code class="function">pcre_exec</code>() as often as
      necessary. For example, to build and use tables that are
      appropriate for the French locale (where accented characters
      with values greater than 128 are treated as letters), the
      following code could be used:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 setlocale(LC_CTYPE, "fr_FR");
 tables = pcre_maketables();
 re = pcre_compile(..., tables);
</pre>
      </div>

      <p>The locale name "fr_FR" is used on Linux and other
      Unix-like systems; if you are using Windows, the name for the
      French locale is "french".</p>

      <p>When <code class="function">pcre_maketables</code>() runs,
      the tables are built in memory that is obtained via
      <code class="function">pcre_malloc</code>. It is the caller's
      responsibility to ensure that the memory containing the
      tables remains available for as long as it is needed.</p>

      <p>The pointer that is passed to <code class="function">pcre_compile</code>() is saved with the compiled
      pattern, and the same tables are used via this pointer by
      <code class="function">pcre_study</code>() and normally also
      by <code class="function">pcre_exec</code>(). Thus, by
      default, for any single pattern, compilation, studying and
      matching all happen in the same locale, but different
      patterns can be compiled in different locales.</p>

      <p>It is possible to pass a table pointer or NULL (indicating
      the use of the internal tables) to <code class="function">pcre_exec</code>(). Although not intended for this
      purpose, this facility could be used to match a pattern in a
      different locale from the one in which it was compiled.
      Passing table pointers at run time is discussed below in the
      section on matching a pattern.</p>
    </div>

    <div class="refsect1" title="INFORMATION ABOUT A PATTERN">
      <a id="pcreapi-3_sect11" name="pcreapi-3_sect11" shape="rect"> </a>

      <h2>INFORMATION ABOUT A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_fullinfo</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The <code class="function">pcre_fullinfo</code>() function
      returns information about a compiled pattern. It replaces the
      obsolete <code class="function">pcre_info</code>() function,
      which is nevertheless retained for backwards compability (and
      is documented below).</p>

      <p>The first argument for <code class="function">pcre_fullinfo</code>() is a pointer to the
      compiled pattern. The second argument is the result of
      <code class="function">pcre_study</code>(), or NULL if the
      pattern was not studied. The third argument specifies which
      piece of information is required, and the fourth argument is
      a pointer to a variable to receive the data. The yield of the
      function is zero for success, or one of the following
      negative numbers:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_ERROR_NULL       the argument <em class="parameter"><code>code</code></em> was NULL
                       the argument <em class="parameter"><code>where</code></em> was NULL
 PCRE_ERROR_BADMAGIC   the "magic number" was not found
 PCRE_ERROR_BADOPTION  the value of <em class="parameter"><code>what</code></em> was invalid
</pre>
      </div>

      <p>The "magic number" is placed at the start of each compiled
      pattern as an simple check against passing an arbitrary
      memory pointer. Here is a typical call of <code class="function">pcre_fullinfo</code>(), to obtain the length of
      the compiled pattern:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 size_t length;
 rc = pcre_fullinfo(
   re,               /* result of pcre_compile() */
   pe,               /* result of pcre_study(), or NULL */
   PCRE_INFO_SIZE,   /* what is required */
   &amp;length);         /* where to put the data */
</pre>
      </div>

      <p>The possible values for the third argument are defined in
      <code class="filename">pcre.h</code>, and are as follows:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_BACKREFMAX</code></span></dt>

          <dd>
            <p>Return the number of the highest back reference in
            the pattern. The fourth argument should point to an
            <span class="type">int</span> variable. Zero is
            returned if there are no back references.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_CAPTURECOUNT</code></span></dt>

          <dd>
            <p>Return the number of capturing subpatterns in the
            pattern. The fourth argument should point to an
            <span class="type">int</span> variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_DEFAULT_TABLES</code></span></dt>

          <dd>
            <p>Return a pointer to the internal default character
            tables within PCRE. The fourth argument should point to
            an <span class="type">unsigned char *</span> variable.
            This information call is provided for internal use by
            the <code class="function">pcre_study</code>()
            function. External callers can cause PCRE to use its
            internal tables by passing a NULL table pointer.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_FIRSTBYTE</code></span></dt>

          <dd>
            <p>Return information about the first byte of any
            matched string, for a non-anchored pattern. The fourth
            argument should point to an <span class="type">int</span> variable. (This option used to be
            called PCRE_INFO_FIRSTCHAR; the old name is still
            recognized for backwards compatibility.)</p>
          </dd>
        </dl>
      </div>

      <p>If there is a fixed first byte, for example, from a
      pattern such as (cat|cow|coyote), its value is returned.
      Otherwise, if either</p>

      <p>(a) the pattern was compiled with the PCRE_MULTILINE
      option, and every branch starts with "^", or</p>

      <p>(b) every branch of the pattern starts with ".*" and
      PCRE_DOTALL is not set (if it were set, the pattern would be
      anchored),</p>

      <p>-1 is returned, indicating that the pattern matches only
      at the start of a subject string or after any newline within
      the string. Otherwise -2 is returned. For anchored patterns,
      -2 is returned.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_FIRSTTABLE</code></span></dt>

          <dd>
            <p>If the pattern was studied, and this resulted in the
            construction of a 256-bit table indicating a fixed set
            of bytes for the first byte in any matching string, a
            pointer to the table is returned. Otherwise NULL is
            returned. The fourth argument should point to an
            <span class="type">unsigned char *</span> variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_HASCRORLF</code></span></dt>

          <dd>
            <p>Return 1 if the pattern contains any explicit
            matches for CR or LF characters, otherwise 0. The
            fourth argument should point to an <span class="type">int</span> variable. An explicit match is either
            a literal CR or LF character, or \r or \n.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_JCHANGED</code></span></dt>

          <dd>
            <p>Return 1 if the (?J) or (?-J) option setting is used
            in the pattern, otherwise 0. The fourth argument should
            point to an <span class="type">int</span> variable.
            (?J) and (?-J) set and unset the local PCRE_DUPNAMES
            option, respectively.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_LASTLITERAL</code></span></dt>

          <dd>
            <p>Return the value of the rightmost literal byte that
            must exist in any matched string, other than at its
            start, if such a byte has been recorded. The fourth
            argument should point to an <span class="type">int</span> variable. If there is no such byte,
            -1 is returned. For anchored patterns, a last literal
            byte is recorded only if it follows something of
            variable length. For example, for the pattern
            /^a\d+z\d+/ the returned value is "z", but for
            /^a\dz\d/ the returned value is -1.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_MINLENGTH</code></span></dt>

          <dd>
            <p>If the pattern was studied and a minimum length for
            matching subject strings was computed, its value is
            returned. Otherwise the returned value is -1. The value
            is a number of characters, not bytes (this may be
            relevant in UTF-8 mode). The fourth argument should
            point to an <span class="type">int</span> variable. A
            non-negative value is a lower bound to the length of
            any matching string. There may not be any strings of
            that length that do actually match, but every string
            that does match is at least that long.</p>

            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
 PCRE_INFO_NAMECOUNT
 PCRE_INFO_NAMEENTRYSIZE
 PCRE_INFO_NAMETABLE
</pre>
            </div>

            <p>PCRE supports the use of named as well as numbered
            capturing parentheses. The names are just an additional
            way of identifying the parentheses, which still acquire
            numbers. Several convenience functions such as
            <code class="function">pcre_get_named_substring</code>() are
            provided for extracting captured substrings by name. It
            is also possible to extract the data directly, by first
            converting the name to a number in order to access the
            correct pointers in the output vector (described with
            <code class="function">pcre_exec</code>() below). To do
            the conversion, you need to use the name-to-number map,
            which is described by these three values.</p>
          </dd>
        </dl>
      </div>

      <p>The map consists of a number of fixed-size entries.
      PCRE_INFO_NAMECOUNT gives the number of entries, and
      PCRE_INFO_NAMEENTRYSIZE gives the size of each entry; both of
      these return an <span class="type">int</span> value. The
      entry size depends on the length of the longest name.
      PCRE_INFO_NAMETABLE returns a pointer to the first entry of
      the table (a pointer to <span class="type">char</span>). The
      first two bytes of each entry are the number of the capturing
      parenthesis, most significant byte first. The rest of the
      entry is the corresponding name, zero terminated.</p>

      <p>The names are in alphabetical order. Duplicate names may
      appear if (?| is used to create multiple groups with the same
      number, as described in the section on duplicate subpattern
      numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page.
      Duplicate names for subpatterns with different numbers are
      permitted only if PCRE_DUPNAMES is set. In all cases of
      duplicate names, they appear in the table in the order in
      which they were found in the pattern. In the absence of (?|
      this is the order of increasing number; when (?| is used this
      is not necessarily the case because later subpatterns may
      have lower numbers.</p>

      <p>As a simple example of the name/number table, consider the
      following pattern (assume PCRE_EXTENDED is set, so white
      space - including newlines - is ignored):</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 (?&lt;date&gt; (?&lt;year&gt;(\d\d)?\d\d) -
 (?&lt;month&gt;\d\d) - (?&lt;day&gt;\d\d) )
</pre>
      </div>

      <p>There are four named subpatterns, so the table has four
      entries, and each entry in the table is eight bytes long. The
      table is as follows, with non-printing bytes shows in
      hexadecimal, and undefined bytes shown as ??:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 00 01 d  a  t  e  00 ??
 00 05 d  a  y  00 ?? ??
 00 04 m  o  n  t  h  00
 00 02 y  e  a  r  00 ??
</pre>
      </div>

      <p>When writing code to extract data from named subpatterns
      using the name-to-number map, remember that the length of the
      entries is likely to be different for each compiled
      pattern.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_OKPARTIAL</code></span></dt>

          <dd>
            <p>Return 1 if the pattern can be used for partial
            matching with <code class="function">pcre_exec</code>(), otherwise 0. The fourth
            argument should point to an <span class="type">int</span> variable. From release 8.00, this
            always returns 1, because the restrictions that
            previously applied to partial matching have been
            lifted. The <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
            documentation gives details of partial matching.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_OPTIONS</code></span></dt>

          <dd>
            <p>Return a copy of the options with which the pattern
            was compiled. The fourth argument should point to an
            <span class="type">unsigned long int</span> variable.
            These option bits are those specified in the call to
            <code class="function">pcre_compile</code>(), modified
            by any top-level option settings at the start of the
            pattern itself. In other words, they are the options
            that will be in force when matching starts. For
            example, if the pattern /(?im)abc(?-i)d/ is compiled
            with the PCRE_EXTENDED option, the result is
            PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.</p>
          </dd>
        </dl>
      </div>

      <p>A pattern is automatically anchored by PCRE if all of its
      top-level alternatives begin with one of the following:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 ^     unless PCRE_MULTILINE is set
 \A    always
 \G    always
 .*    if PCRE_DOTALL is set and there are no back
         references to the subpattern in which .* appears
</pre>
      </div>

      <p>For such patterns, the PCRE_ANCHORED bit is set in the
      options returned by <code class="function">pcre_fullinfo</code>().</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_SIZE</code></span></dt>

          <dd>
            <p>Return the size of the compiled pattern, that is,
            the value that was passed as the argument to
            <code class="function">pcre_malloc</code>() when PCRE
            was getting memory in which to place the compiled data.
            The fourth argument should point to a <em class="parameter"><code>size_t</code></em> variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_STUDYSIZE</code></span></dt>

          <dd>
            <p>Return the size of the data block pointed to by the
            <em class="parameter"><code>study_data</code></em>
            field in a <span class="type">pcre_extra</span> block.
            That is, it is the value that was passed to
            <code class="function">pcre_malloc</code>() when PCRE
            was getting memory into which to place the data created
            by <code class="function">pcre_study</code>(). If
            <span class="type">pcre_extra</span> is NULL, or there
            is no study data, zero is returned. The fourth argument
            should point to a <em class="parameter"><code>size_t</code></em> variable.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="OBSOLETE INFO FUNCTION">
      <a id="pcreapi-3_sect12" name="pcreapi-3_sect12" shape="rect"> </a>

      <h2>OBSOLETE INFO FUNCTION</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_info</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">optptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int*<var class="pdparam">firstcharptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The <code class="function">pcre_info</code>() function is
      now obsolete because its interface is too restrictive to
      return all the available data about a compiled pattern. New
      programs should use <code class="function">pcre_fullinfo</code>() instead. The yield of
      <code class="function">pcre_info</code>() is the number of
      capturing subpatterns, or one of the following negative
      numbers:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_ERROR_NULL       the argument <em class="parameter"><code>code</code></em> was NULL
 PCRE_ERROR_BADMAGIC   the "magic number" was not found
</pre>
      </div>

      <p>If the <em class="parameter"><code>optptr</code></em>
      argument is not NULL, a copy of the options with which the
      pattern was compiled is placed in the integer it points to
      (see PCRE_INFO_OPTIONS above).</p>

      <p>If the pattern is not anchored and the <em class="parameter"><code>firstcharptr</code></em> argument is not
      NULL, it is used to pass back information about the first
      character of any matched string (see PCRE_INFO_FIRSTBYTE
      above).</p>
    </div>

    <div class="refsect1" title="REFERENCE COUNTS">
      <a id="pcreapi-3_sect13" name="pcreapi-3_sect13" shape="rect"> </a>

      <h2>REFERENCE COUNTS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_refcount</b>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">adjust</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The <code class="function">pcre_refcount</code>() function
      is used to maintain a reference count in the data block that
      contains a compiled pattern. It is provided for the benefit
      of applications that operate in an object-oriented manner,
      where different parts of the application may be using the
      same compiled pattern, but you want to free the block when
      they are all done.</p>

      <p>When a pattern is compiled, the reference count field is
      initialized to zero. It is changed only by calling this
      function, whose action is to add the <em class="parameter"><code>adjust</code></em> value (which may be
      positive or negative) to it. The yield of the function is the
      new value. However, the value of the count is constrained to
      lie between 0 and 65535, inclusive. If the new value is
      outside these limits, it is forced to the appropriate limit
      value.</p>

      <p>Except when it is zero, the reference count is not
      correctly preserved if a pattern is compiled on one host and
      then transferred to a host whose byte-order is different.
      (This seems a highly unlikely scenario.)</p>
    </div>

    <div class="refsect1" title="MATCHING A PATTERN: THE TRADITIONAL FUNCTION">
      <a id="pcreapi-3_sect14" name="pcreapi-3_sect14" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_exec</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_exec</code>() is
      called to match a subject string against a compiled pattern,
      which is passed in the <em class="parameter"><code>code</code></em> argument. If the pattern
      was studied, the result of the study should be passed in the
      <em class="parameter"><code>extra</code></em> argument. This
      function is the main matching facility of the library, and it
      operates in a Perl-like manner. For specialist use there is
      also an alternative matching function, which is described
      below in the section about the <code class="function">pcre_dfa_exec</code>() function.</p>

      <p>In most applications, the pattern will have been compiled
      (and optionally studied) in the same process that calls
      <code class="function">pcre_exec</code>(). However, it is
      possible to save compiled patterns and study data, and then
      use them later in different processes, possibly even on
      different hosts. For a discussion about this, see the
      <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[30];
 rc = pcre_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   30);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2" title="Extra data for pcre_exec()">
        <a id="pcreapi-3_sect15" name="pcreapi-3_sect15" shape="rect"> </a>

        <h3>Extra data for <code class="function">pcre_exec</code>()</h3>

        <p>If the <em class="parameter"><code>extra</code></em>
        argument is not NULL, it must point to a <span class="type">pcre_extra</span> data block. The <code class="function">pcre_study</code>() function returns such a
        block (when it doesn't return NULL), but you can also
        create one for yourself, and pass additional information in
        it. The <span class="type">pcre_extra</span> block contains
        the following fields (not necessarily in this order):</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 unsigned long int <em class="parameter"><code>flags</code></em>;
 void *<em class="parameter"><code>study_data</code></em>;
 unsigned long int <em class="parameter"><code>match_limit</code></em>;
 unsigned long int <em class="parameter"><code>match_limit_recursion</code></em>;
 void *<em class="parameter"><code>callout_data</code></em>;
 const unsigned char *<em class="parameter"><code>tables</code></em>;
 unsigned char **<code class="function">mark</code>;
</pre>
        </div>

        <p>The <em class="parameter"><code>flags</code></em> field
        is a bitmap that specifies which of the other fields are
        set. The flag bits are:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_EXTRA_STUDY_DATA
 PCRE_EXTRA_MATCH_LIMIT
 PCRE_EXTRA_MATCH_LIMIT_RECURSION
 PCRE_EXTRA_CALLOUT_DATA
 PCRE_EXTRA_TABLES
 PCRE_EXTRA_MARK
</pre>
        </div>

        <p>Other flag bits should be set to zero. The <em class="parameter"><code>study_data</code></em> field is set in
        the <span class="type">pcre_extra</span> block that is
        returned by <code class="function">pcre_study</code>(),
        together with the appropriate flag bit. You should not set
        this yourself, but you may add to the block by setting the
        other fields and their corresponding flag bits.</p>

        <p>The <em class="parameter"><code>match_limit</code></em>
        field provides a means of preventing PCRE from using up a
        vast amount of resources when running patterns that are not
        going to match, but which have a very large number of
        possibilities in their search trees. The classic example is
        a pattern that uses nested unlimited repeats.</p>

        <p>Internally, PCRE uses a function called <code class="function">match</code>() which it calls repeatedly
        (sometimes recursively). The limit set by <em class="parameter"><code>match_limit</code></em> is imposed on the
        number of times this function is called during a match,
        which has the effect of limiting the amount of backtracking
        that can take place. For patterns that are not anchored,
        the count restarts from zero for each position in the
        subject string.</p>

        <p>The default value for the limit can be set when PCRE is
        built; the default default is 10 million, which handles all
        but the most extreme cases. You can override the default by
        suppling <code class="function">pcre_exec</code>() with a
        <span class="type">pcre_extra</span> block in which
        <em class="parameter"><code>match_limit</code></em> is set,
        and PCRE_EXTRA_MATCH_LIMIT is set in the <em class="parameter"><code>flags</code></em> field. If the limit is
        exceeded, <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_MATCHLIMIT.</p>

        <p>The <em class="parameter"><code>match_limit_recursion</code></em> field
        is similar to <em class="parameter"><code>match_limit</code></em>, but instead of
        limiting the total number of times that <code class="function">match</code>() is called, it limits the depth of
        recursion. The recursion depth is a smaller number than the
        total number of calls, because not all calls to
        <code class="function">match</code>() are recursive. This
        limit is of use only if it is set smaller than <em class="parameter"><code>match_limit</code></em>.</p>

        <p>Limiting the recursion depth limits the amount of stack
        that can be used, or, when PCRE has been compiled to use
        memory on the heap instead of the stack, the amount of heap
        memory that can be used.</p>

        <p>The default value for <em class="parameter"><code>match_limit_recursion</code></em> can be
        set when PCRE is built; the default default is the same
        value as the default for <em class="parameter"><code>match_limit</code></em>. You can override
        the default by suppling <code class="function">pcre_exec</code>() with a <span class="type">pcre_extra</span> block in which <em class="parameter"><code>match_limit_recursion</code></em> is set,
        and PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the
        <em class="parameter"><code>flags</code></em> field. If the
        limit is exceeded, <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_RECURSIONLIMIT.</p>

        <p>The <em class="parameter"><code>callout_data</code></em>
        field is used in conjunction with the "callout" feature,
        and is described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation.</p>

        <p>The <em class="parameter"><code>tables</code></em> field
        is used to pass a character tables pointer to <code class="function">pcre_exec</code>(); this overrides the value
        that is stored with the compiled pattern. A non-NULL value
        is stored with the compiled pattern only if custom tables
        were supplied to <code class="function">pcre_compile</code>() via its <em class="parameter"><code>tableptr</code></em> argument. If NULL is
        passed to <code class="function">pcre_exec</code>() using
        this mechanism, it forces PCRE's internal tables to be
        used. This facility is helpful when re-using patterns that
        have been saved after compiling with an external set of
        tables, because the external tables might be at a different
        address when <code class="function">pcre_exec</code>() is
        called. See the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
        documentation for a discussion of saving compiled patterns
        for later use.</p>

        <p>If PCRE_EXTRA_MARK is set in the <em class="parameter"><code>flags</code></em> field, the <code class="function">mark</code> field must be set to point to a
        <span class="emphasis"><em>char *</em></span> variable. If
        the pattern contains any backtracking control verbs such as
        (*MARK:NAME), and the execution ends up with a name to pass
        back, a pointer to the name string (zero terminated) is
        placed in the variable pointed to by the <code class="function">mark</code> field. The names are within the
        compiled pattern; if you wish to retain such a name you
        must copy it before freeing the memory of a compiled
        pattern. If there is no name to pass back, the variable
        pointed to by the <code class="function">mark</code> field
        set to NULL. For details of the backtracking control verbs,
        see the section entitled "Backtracking control" in the
        <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2" title="Option bits for pcre_exec()">
        <a id="pcreapi-3_sect16" name="pcreapi-3_sect16" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_exec</code>() must be zero. The
        only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_START_OPTIMIZE,
        PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_SOFT, and
        PCRE_PARTIAL_HARD.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_ANCHORED</code></span></dt>

            <dd>
              <p>The PCRE_ANCHORED option limits <code class="function">pcre_exec</code>() to matching at the
              first matching position. If a pattern was compiled
              with PCRE_ANCHORED, or turned out to be anchored by
              virtue of its contents, it cannot be made unachored
              at matching time.</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
              </div>

              <p>These options (which are mutually exclusive)
              control what the \R escape sequence matches. The
              choice is either to match only CR, LF, or CRLF, or to
              match any Unicode newline sequence. These options
              override the choice that was made or defaulted when
              the pattern was compiled.</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
              </div>

              <p>These options override the newline definition that
              was chosen or defaulted when the pattern was
              compiled. For details, see the description of
              <code class="function">pcre_compile</code>() above.
              During matching, the newline choice affects the
              behaviour of the dot, circumflex, and dollar
              metacharacters. It may also alter the way the match
              position is advanced after a match failure for an
              unanchored pattern.</p>
            </dd>
          </dl>
        </div>

        <p>When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or
        PCRE_NEWLINE_ANY is set, and a match attempt for an
        unanchored pattern fails when the current position is at a
        CRLF sequence, and the pattern contains no explicit matches
        for CR or LF characters, the match position is advanced by
        two characters instead of one, in other words, to after the
        CRLF.</p>

        <p>The above rule is a compromise that makes the most
        common cases work as expected. For example, if the pattern
        is .+A (and the PCRE_DOTALL option is not set), it does not
        match the string "\r\nA" because, after failing at the
        start, it skips both the CR and the LF before retrying.
        However, the pattern [\r\n]A does match that string,
        because it contains an explicit CR or LF reference, and so
        advances only by one character after the first failure.</p>

        <p>An explicit match for CR of LF is either a literal
        appearance of one of those characters, or one of the \r or
        \n escape sequences. Implicit matches such as [^X] do not
        count, nor does \s (which includes CR and LF in the
        characters that it matches).</p>

        <p>Notwithstanding the above, anomalous effects may still
        occur when CRLF is a valid newline sequence and explicit \r
        or \n escapes appear in the pattern.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NOTBOL</code></span></dt>

            <dd>
              <p>This option specifies that first character of the
              subject string is not the beginning of a line, so the
              circumflex metacharacter should not match before it.
              Setting this without PCRE_MULTILINE (at compile time)
              causes circumflex never to match. This option affects
              only the behaviour of the circumflex metacharacter.
              It does not affect \A.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEOL</code></span></dt>

            <dd>
              <p>This option specifies that the end of the subject
              string is not the end of a line, so the dollar
              metacharacter should not match it nor (except in
              multiline mode) a newline immediately before it.
              Setting this without PCRE_MULTILINE (at compile time)
              causes dollar never to match. This option affects
              only the behaviour of the dollar metacharacter. It
              does not affect \Z or \z.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEMPTY</code></span></dt>

            <dd>
              <p>An empty string is not considered to be a valid
              match if this option is set. If there are
              alternatives in the pattern, they are tried. If all
              the alternatives match the empty string, the entire
              match fails. For example, if the pattern</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
a?b?
</pre>
              </div>

              <p>is applied to a string not beginning with "a" or
              "b", it matches an empty string at the start of the
              subject. With PCRE_NOTEMPTY set, this match is not
              valid, so PCRE searches further into the string for
              occurrences of "a" or "b".</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEMPTY_ATSTART</code></span></dt>

            <dd>
              <p>This is like PCRE_NOTEMPTY, except that an empty
              string match that is not at the start of the subject
              is permitted. If the pattern is anchored, such a
              match can occur only if the pattern contains \K.</p>
            </dd>
          </dl>
        </div>

        <p>Perl has no direct equivalent of PCRE_NOTEMPTY or
        PCRE_NOTEMPTY_ATSTART, but it does make a special case of a
        pattern match of the empty string within its <code class="function">split</code>() function, and when using the /g
        modifier. It is possible to emulate Perl's behaviour after
        matching a null string by first trying the match again at
        the same offset with PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED, and then if that fails, by advancing the
        starting offset (see below) and trying an ordinary match
        again. There is some code that demonstrates how to do this
        in the <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> sample program.
        In the most general case, you have to check to see if the
        newline convention recognizes CRLF as a newline, and if so,
        and the current character is CR followed by LF, advance the
        starting offset by two characters instead of one.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NO_START_OPTIMIZE</code></span></dt>

            <dd>
              <p>There are a number of optimizations that
              <code class="function">pcre_exec</code>() uses at the
              start of a match, in order to speed up the process.
              For example, if it is known that an unanchored match
              must start with a specific character, it searches the
              subject for that character, and fails immediately if
              it cannot find it, without actually running the main
              matching function. This means that a special item
              such as (*COMMIT) at the start of a pattern is not
              considered until after a suitable starting point for
              the match has been found. When callouts or (*MARK)
              items are in use, these "start-up" optimizations can
              cause them to be skipped if the pattern is never
              actually used. The start-up optimizations are in
              effect a pre-scan of the subject that takes place
              before the pattern is run.</p>
            </dd>
          </dl>
        </div>

        <p>The PCRE_NO_START_OPTIMIZE option disables the start-up
        optimizations, possibly causing performance to suffer, but
        ensuring that in cases where the result is "no match", the
        callouts do occur, and that items such as (*COMMIT) and
        (*MARK) are considered at every possible starting position
        in the subject string. If PCRE_NO_START_OPTIMIZE is set at
        compile time, it cannot be unset at matching time.</p>

        <p>Setting PCRE_NO_START_OPTIMIZE can change the outcome of
        a matching operation. Consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*COMMIT)ABC
</pre>
        </div>

        <p>When this is compiled, PCRE records the fact that a
        match must start with the character "A". Suppose the
        subject string is "DEFABC". The start-up optimization scans
        along the subject, finds "A" and runs the first match
        attempt from there. The (*COMMIT) item means that the
        pattern must match the current starting position, which in
        this case, it does. However, if the same match is run with
        PCRE_NO_START_OPTIMIZE set, the initial scan along the
        subject string does not happen. The first match attempt is
        run starting from "D" and when this fails, (*COMMIT)
        prevents any further matches being tried, so the overall
        result is "no match". If the pattern is studied, more
        start-up optimizations may be used. For example, a minimum
        length for the subject may be recorded. Consider the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*MARK:A)(X|Y)
</pre>
        </div>

        <p>The minimum length for a match is one character. If the
        subject is "ABC", there will be attempts to match "ABC",
        "BC", "C", and then finally an empty string. If the pattern
        is studied, the final attempt does not take place, because
        PCRE knows that the subject is too short, and so the
        (*MARK) is never encountered. In this case, studying the
        pattern does not affect the overall match result, which is
        still "no match", but it does affect the auxiliary
        information that is returned.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NO_UTF8_CHECK</code></span></dt>

            <dd>
              <p>When PCRE_UTF8 is set at compile time, the
              validity of the subject as a UTF-8 string is
              automatically checked when <code class="function">pcre_exec</code>() is subsequently called.
              The value of <em class="parameter"><code>startoffset</code></em> is also
              checked to ensure that it points to the start of a
              UTF-8 character. There is a discussion about the
              validity of UTF-8 strings in the section on UTF-8
              support in the main <a class="link" href="../htmlman3/pcre.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre</span>(3)</span></a> page. If an
              invalid UTF-8 sequence of bytes is found,
              <code class="function">pcre_exec</code>() returns the
              error PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is
              set and the problem is a truncated UTF-8 character at
              the end of the subject, PCRE_ERROR_SHORTUTF8. If
              <em class="parameter"><code>startoffset</code></em>
              contains a value that does not point to the start of
              a UTF-8 character (or to the end of the subject),
              PCRE_ERROR_BADUTF8_OFFSET is returned.</p>
            </dd>
          </dl>
        </div>

        <p>If you already know that your subject is valid, and you
        want to skip these checks for performance reasons, you can
        set the PCRE_NO_UTF8_CHECK option when calling <code class="function">pcre_exec</code>(). You might want to do this
        for the second and subsequent calls to <code class="function">pcre_exec</code>() if you are making repeated
        calls to find all the matches in a single subject string.
        However, you should be sure that the value of <em class="parameter"><code>startoffset</code></em> points to the
        start of a UTF-8 character (or the end of the subject).
        When PCRE_NO_UTF8_CHECK is set, the effect of passing an
        invalid UTF-8 string as a subject or an invalid value of
        <em class="parameter"><code>startoffset</code></em> is
        undefined. Your program may crash.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These options turn on the partial matching feature. For
        backwards compatibility, PCRE_PARTIAL is a synonym for
        PCRE_PARTIAL_SOFT. A partial match occurs if the end of the
        subject string is reached successfully, but there are not
        enough subject characters to complete the match. If this
        happens when PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD)
        is set, matching continues by testing any remaining
        alternatives. Only if no complete match can be found is
        PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH.
        In other words, PCRE_PARTIAL_SOFT says that the caller is
        prepared to handle a partial match, but only if no complete
        match can be found.</p>

        <p>If PCRE_PARTIAL_HARD is set, it overrides
        PCRE_PARTIAL_SOFT. In this case, if a partial match is
        found, <code class="function">pcre_exec</code>()
        immediately returns PCRE_ERROR_PARTIAL, without considering
        any other alternatives. In other words, when
        PCRE_PARTIAL_HARD is set, a partial match is considered to
        be more important that an alternative complete match.</p>

        <p>In both cases, the portion of the string that was
        inspected when the partial match was found is set as the
        first matching string. There is a more detailed discussion
        of partial and multi-segment matching, with examples, in
        the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2" title="The string to be matched by pcre_exec()">
        <a id="pcreapi-3_sect17" name="pcreapi-3_sect17" shape="rect"> </a>

        <h3>The string to be matched by <code class="function">pcre_exec</code>()</h3>

        <p>The subject string is passed to <code class="function">pcre_exec</code>() as a pointer in <em class="parameter"><code>subject</code></em>, a length (in bytes)
        in <em class="parameter"><code>length</code></em>, and a
        starting byte offset in <em class="parameter"><code>startoffset</code></em>. If this is
        negative or greater than the length of the subject,
        <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_BADOFFSET. When the starting offset is zero, the
        search for a match starts at the beginning of the subject,
        and this is by far the most common case. In UTF-8 mode, the
        byte offset must point to the start of a UTF-8 character
        (or the end of the subject). Unlike the pattern string, the
        subject may contain binary zero bytes.</p>

        <p>A non-zero starting offset is useful when searching for
        another match in the same subject by calling <code class="function">pcre_exec</code>() again after a previous
        success. Setting <em class="parameter"><code>startoffset</code></em> differs from just
        passing over a shortened string and setting PCRE_NOTBOL in
        the case of a pattern that begins with any kind of
        lookbehind. For example, consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
\Biss\B
</pre>
        </div>

        <p>which finds occurrences of "iss" in the middle of words.
        (\B matches only if the current position in the subject is
        not a word boundary.) When applied to the string
        "Mississipi" the first call to <code class="function">pcre_exec</code>() finds the first occurrence.
        If <code class="function">pcre_exec</code>() is called
        again with just the remainder of the subject, namely
        "issipi", it does not match, because \B is always false at
        the start of the subject, which is deemed to be a word
        boundary. However, if <code class="function">pcre_exec</code>() is passed the entire string
        again, but with <em class="parameter"><code>startoffset</code></em> set to 4, it
        finds the second occurrence of "iss" because it is able to
        look behind the starting point to discover that it is
        preceded by a letter.</p>

        <p>Finding all the matches in a subject is tricky when the
        pattern can match an empty string. It is possible to
        emulate Perl's /g behaviour by first trying the match again
        at the same offset, with the PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED options, and then if that fails, advancing
        the starting offset and trying an ordinary match again.
        There is some code that demonstrates how to do this in the
        <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> sample program.
        In the most general case, you have to check to see if the
        newline convention recognizes CRLF as a newline, and if so,
        and the current character is CR followed by LF, advance the
        starting offset by two characters instead of one.</p>

        <p>If a non-zero starting offset is passed when the pattern
        is anchored, one attempt to match at the given offset is
        made. This can only succeed if the pattern does not require
        the match to be at the start of the subject.</p>
      </div>

      <div class="refsect2" title="How pcre_exec() returns captured substrings">
        <a id="pcreapi-3_sect18" name="pcreapi-3_sect18" shape="rect"> </a>

        <h3>How <code class="function">pcre_exec</code>() returns
        captured substrings</h3>

        <p>In general, a pattern matches a certain portion of the
        subject, and in addition, further substrings from the
        subject may be picked out by parts of the pattern.
        Following the usage in Jeffrey Friedl's book, this is
        called "capturing" in what follows, and the phrase
        "capturing subpattern" is used for a fragment of a pattern
        that picks out a substring. PCRE supports several other
        kinds of parenthesized subpattern that do not cause
        substrings to be captured.</p>

        <p>Captured substrings are returned to the caller via a
        vector of integers whose address is passed in <em class="parameter"><code>ovector</code></em>. The number of
        elements in the vector is passed in <em class="parameter"><code>ovecsize</code></em>, which must be a
        non-negative number. <code class="function">Note</code>:
        this argument is NOT the size of <em class="parameter"><code>ovector</code></em> in bytes.</p>

        <p>The first two-thirds of the vector is used to pass back
        captured substrings, each substring using a pair of
        integers. The remaining third of the vector is used as
        workspace by <code class="function">pcre_exec</code>()
        while matching capturing subpatterns, and is not available
        for passing back information. The number passed in
        <em class="parameter"><code>ovecsize</code></em> should
        always be a multiple of three. If it is not, it is rounded
        down.</p>

        <p>When a match is successful, information about captured
        substrings is returned in pairs of integers, starting at
        the beginning of <em class="parameter"><code>ovector</code></em>, and continuing up to
        two-thirds of its length at the most. The first element of
        each pair is set to the byte offset of the first character
        in a substring, and the second is set to the byte offset of
        the first character after the end of a substring.
        <code class="function">Note</code>: these values are always
        byte offsets, even in UTF-8 mode. They are not character
        counts.</p>

        <p>The first pair of integers, <em class="replaceable"><code>ovector[0]</code></em> and <em class="replaceable"><code>ovector[1]</code></em>, identify the
        portion of the subject string matched by the entire
        pattern. The next pair is used for the first capturing
        subpattern, and so on. The value returned by <code class="function">pcre_exec</code>() is one more than the highest
        numbered pair that has been set. For example, if two
        substrings have been captured, the returned value is 3. If
        there are no capturing subpatterns, the return value from a
        successful match is 1, indicating that just the first pair
        of offsets has been set.</p>

        <p>If a capturing subpattern is matched repeatedly, it is
        the last portion of the string that it matched that is
        returned.</p>

        <p>If the vector is too small to hold all the captured
        substring offsets, it is used as far as possible (up to
        two-thirds of its length), and the function returns a value
        of zero. If the substring offsets are not of interest,
        <code class="function">pcre_exec</code>() may be called
        with <em class="parameter"><code>ovector</code></em> passed
        as NULL and <em class="parameter"><code>ovecsize</code></em> as zero. However, if
        the pattern contains back references and the <em class="parameter"><code>ovector</code></em> is not big enough to
        remember the related substrings, PCRE has to get additional
        memory for use during matching. Thus it is usually
        advisable to supply an <em class="parameter"><code>ovector</code></em>.</p>

        <p>The <code class="function">pcre_fullinfo</code>()
        function can be used to find out how many capturing
        subpatterns there are in a compiled pattern. The smallest
        size for <em class="parameter"><code>ovector</code></em>
        that will allow for <code class="literal">n</code> captured
        substrings, in addition to the offsets of the substring
        matched by the whole pattern, is (<code class="literal">n</code>+1)*3.</p>

        <p>It is possible for capturing subpattern number
        <em class="replaceable"><code>n+1</code></em> to match some
        part of the subject when subpattern <code class="literal">n</code> has not been used at all. For example,
        if the string "abc" is matched against the pattern
        (a|(z))(bc) the return from the function is 4, and
        subpatterns 1 and 3 are matched, but 2 is not. When this
        happens, both values in the offset pairs corresponding to
        unused subpatterns are set to -1.</p>

        <p>Offset values that correspond to unused subpatterns at
        the end of the expression are also set to -1. For example,
        if the string "abc" is matched against the pattern
        (abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The
        return from the function is 2, because the highest used
        capturing subpattern number is 1, and the offsets for for
        the second and third capturing subpatterns (assuming the
        vector is large enough, of course) are set to -1.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Note">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>

              <th align="left" rowspan="1" colspan="1">Note</th>
            </tr>

            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>Elements of <em class="parameter"><code>ovector</code></em> that do not
                correspond to capturing parentheses in the pattern
                are never changed. That is, if a pattern contains
                <code class="literal">n</code> capturing
                parentheses, no more than <em class="replaceable"><code>ovector[0]</code></em> to
                <em class="replaceable"><code>ovector[2n+1]</code></em> are
                set by <code class="function">pcre_exec</code>().
                The other elements retain whatever values they
                previously had.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>Some convenience functions are provided for extracting
        the captured substrings as separate strings. These are
        described below.</p>
      </div>

      <div class="refsect2" title="Error return values from pcre_exec()">
        <a id="pcreapi-3_sect19" name="pcreapi-3_sect19" shape="rect"> </a>

        <h3>Error return values from <code class="function">pcre_exec</code>()</h3>

        <p>If <code class="function">pcre_exec</code>() fails, it
        returns a negative number. The following are defined in the
        header file:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMATCH        (-1)
</pre>
        </div>

        <p>The subject string did not match the pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NULL           (-2)
</pre>
        </div>

        <p>Either <em class="parameter"><code>code</code></em> or
        <em class="parameter"><code>subject</code></em> was passed
        as NULL, or <em class="parameter"><code>ovector</code></em>
        was NULL and <em class="parameter"><code>ovecsize</code></em> was not zero.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOPTION      (-3)
</pre>
        </div>

        <p>An unrecognized bit was set in the <em class="parameter"><code>options</code></em> argument.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADMAGIC       (-4)
</pre>
        </div>

        <p>PCRE stores a 4-byte "magic number" at the start of the
        compiled code, to catch the case when it is passed a junk
        pointer and to detect when a pattern that was compiled in
        an environment of one endianness is run in an environment
        with the other endianness. This is the error that PCRE
        gives when the magic number is not present.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_UNKNOWN_OPCODE (-5)
</pre>
        </div>

        <p>While running the pattern match, an unknown item was
        encountered in the compiled pattern. This error could be
        caused by a bug in PCRE or by overwriting of the compiled
        pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
        </div>

        <p>If a pattern contains back references, but the
        <em class="parameter"><code>ovector</code></em> that is
        passed to <code class="function">pcre_exec</code>() is not
        big enough to remember the referenced substrings, PCRE gets
        a block of memory at the start of matching to use for this
        purpose. If the call via <code class="function">pcre_malloc</code>() fails, this error is given.
        The memory is automatically freed at the end of
        matching.</p>

        <p>This error is also given if <code class="function">pcre_stack_malloc</code>() fails in <code class="function">pcre_exec</code>(). This can happen only when
        PCRE has been compiled with <code class="option">−−disable−stack−for−recursion</code>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
        </div>

        <p>This error is used by the <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() functions (see
        below). It is never returned by <code class="function">pcre_exec</code>().</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_MATCHLIMIT     (-8)
</pre>
        </div>

        <p>The backtracking limit, as specified by the <em class="parameter"><code>match_limit</code></em> field in a
        <span class="type">pcre_extra</span> structure (or
        defaulted) was reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_CALLOUT        (-9)
</pre>
        </div>

        <p>This error is never generated by <code class="function">pcre_exec</code>() itself. It is provided for
        use by callout functions that want to yield a distinctive
        error code. See the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation for details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8        (-10)
</pre>
        </div>

        <p>A string that contains an invalid UTF-8 byte sequence
        was passed as a subject. However, if PCRE_PARTIAL_HARD is
        set and the problem is a truncated UTF-8 character at the
        end of the subject, PCRE_ERROR_SHORTUTF8 is used
        instead.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8_OFFSET (-11)
</pre>
        </div>

        <p>The UTF-8 byte sequence that was passed as a subject was
        valid, but the value of <em class="parameter"><code>startoffset</code></em> did not point to
        the beginning of a UTF-8 character or the end of the
        subject.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_PARTIAL        (-12)
</pre>
        </div>

        <p>The subject string did not match, but it did match
        partially. See the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation for details of partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADPARTIAL     (-13)
</pre>
        </div>

        <p>This code is no longer in use. It was formerly returned
        when the PCRE_PARTIAL option was used with a compiled
        pattern containing items that were not supported for
        partial matching. From release 8.00 onwards, there are no
        restrictions on partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_INTERNAL       (-14)
</pre>
        </div>

        <p>An unexpected internal error has occurred. This error
        could be caused by a bug in PCRE or by overwriting of the
        compiled pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADCOUNT       (-15)
</pre>
        </div>

        <p>This error is given if the value of the <em class="parameter"><code>ovecsize</code></em> argument is
        negative.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_RECURSIONLIMIT (-21)
</pre>
        </div>

        <p>The internal recursion limit, as specified by the
        <em class="parameter"><code>match_limit_recursion</code></em> field
        in a <span class="type">pcre_extra</span> structure (or
        defaulted) was reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADNEWLINE     (-23)
</pre>
        </div>

        <p>An invalid combination of PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em> options was given.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOFFSET      (-24)
</pre>
        </div>

        <p>The value of <em class="parameter"><code>startoffset</code></em> was negative or
        greater than the length of the subject, that is, the value
        in <em class="parameter"><code>length</code></em>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_SHORTUTF8      (-25)
</pre>
        </div>

        <p>The subject string ended with an incomplete (truncated)
        UTF-8 character, and the PCRE_PARTIAL_HARD option was set.
        Without this option, PCRE_ERROR_BADUTF8 is returned in this
        situation.</p>

        <p>Error numbers -16 to -20 and -22 are not used by
        <code class="function">pcre_exec</code>().</p>
      </div>
    </div>

    <div class="refsect1" title="EXTRACTING CAPTURED SUBSTRINGS BY NUMBER">
      <a id="pcreapi-3_sect20" name="pcreapi-3_sect20" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_copy_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_substring_list</b>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char ***<var class="pdparam">listptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>Captured substrings can be accessed directly by using the
      offsets returned by <code class="function">pcre_exec</code>()
      in <em class="parameter"><code>ovector</code></em>. For
      convenience, the functions <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() are provided for
      extracting captured substrings as new, separate,
      zero-terminated strings. These functions identify substrings
      by number. The next section describes functions for
      extracting named substrings.</p>

      <p>A substring that contains a binary zero is correctly
      extracted and has a further zero added on the end, but the
      result is not, of course, a C string. However, you can
      process such a string by referring to the length that is
      returned by <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>(). Unfortunately, the
      interface to <code class="function">pcre_get_substring_list</code>() is not adequate
      for handling strings containing binary zeros, because the end
      of the final string is not independently indicated.</p>

      <p>The first three arguments are the same for all three of
      these functions: <em class="parameter"><code>subject</code></em> is the subject string
      that has just been successfully matched, <em class="parameter"><code>ovector</code></em> is a pointer to the
      vector of integer offsets that was passed to <code class="function">pcre_exec</code>(), and <em class="parameter"><code>stringcount</code></em> is the number of
      substrings that were captured by the match, including the
      substring that matched the entire regular expression. This is
      the value returned by <code class="function">pcre_exec</code>() if it is greater than zero. If
      <code class="function">pcre_exec</code>() returned zero,
      indicating that it ran out of space in <em class="parameter"><code>ovector</code></em>, the value passed as
      <em class="parameter"><code>stringcount</code></em> should be
      the number of elements in the vector divided by three.</p>

      <p>The functions <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>() extract a single
      substring, whose number is given as <em class="parameter"><code>stringnumber</code></em>. A value of zero
      extracts the substring that matched the entire pattern,
      whereas higher values extract the captured substrings. For
      <code class="function">pcre_copy_substring</code>(), the
      string is placed in <em class="parameter"><code>buffer</code></em>, whose length is given
      by <em class="parameter"><code>buffersize</code></em>, while
      for <code class="function">pcre_get_substring</code>() a new
      block of memory is obtained via <code class="function">pcre_malloc</code>, and its address is returned
      via <em class="parameter"><code>stringptr</code></em>. The
      yield of the function is the length of the string, not
      including the terminating zero, or one of these error
      codes:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>The buffer was too small for <code class="function">pcre_copy_substring</code>(), or the attempt to
      get memory failed for <code class="function">pcre_get_substring</code>().</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
      </div>

      <p>There is no substring whose number is <em class="parameter"><code>stringnumber</code></em>.</p>

      <p>The <code class="function">pcre_get_substring_list</code>() function extracts
      all available substrings and builds a list of pointers to
      them. All this is done in a single block of memory that is
      obtained via <code class="function">pcre_malloc</code>. The
      address of the memory block is returned via <em class="parameter"><code>listptr</code></em>, which is also the
      start of the list of string pointers. The end of the list is
      marked by a NULL pointer. The yield of the function is zero
      if all went well, or the error code</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>if the attempt to get the memory block failed.</p>

      <p>When any of these functions encounter a substring that is
      unset, which can happen when capturing subpattern number
      <em class="replaceable"><code>n+1</code></em> matches some
      part of the subject, but subpattern <code class="literal">n</code> has not been used at all, they return an
      empty string. This can be distinguished from a genuine
      zero-length substring by inspecting the appropriate offset in
      <em class="parameter"><code>ovector</code></em>, which is
      negative for unset substrings.</p>

      <p>The two convenience functions <code class="function">pcre_free_substring</code>() and <code class="function">pcre_free_substring_list</code>() can be used to
      free the memory returned by a previous call of <code class="function">pcre_get_substring</code>() or <code class="function">pcre_get_substring_list</code>(), respectively.
      They do nothing more than call the function pointed to by
      <code class="function">pcre_free</code>, which of course
      could be called directly from a C program. However, PCRE is
      used in some situations where it is linked via a special
      interface to another programming language that cannot use
      <code class="function">pcre_free</code> directly; it is for
      these cases that the functions are provided.</p>
    </div>

    <div class="refsect1" title="EXTRACTING CAPTURED SUBSTRINGS BY NAME">
      <a id="pcreapi-3_sect21" name="pcreapi-3_sect21" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_stringnumber</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_copy_named_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_named_substring</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>To extract a substring by name, you first have to find
      associated number. For example, for this pattern</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
(a+)b(?&lt;xxx&gt;\d+)...
</pre>
      </div>

      <p>the number of the subpattern called "xxx" is 2. If the
      name is known to be unique (PCRE_DUPNAMES was not set), you
      can find the number from the name by calling <code class="function">pcre_get_stringnumber</code>(). The first argument
      is the compiled pattern, and the second is the name. The
      yield of the function is the subpattern number, or
      PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of that
      name.</p>

      <p>Given the number, you can extract the substring directly,
      or use one of the functions described in the previous
      section. For convenience, there are also two functions that
      do the whole job.</p>

      <p>Most of the arguments of <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>() are
      the same as those for the similarly named functions that
      extract by number. As these are described in the previous
      section, they are not re-described here. There are just two
      differences:</p>

      <p>First, instead of a substring number, a substring name is
      given. Second, there is an extra argument, given at the
      start, which is a pointer to the compiled pattern. This is
      needed in order to gain access to the name-to-number
      translation table.</p>

      <p>These functions call <code class="function">pcre_get_stringnumber</code>(), and if it
      succeeds, they then call <code class="function">pcre_copy_substring</code>() or <code class="function">pcre_get_substring</code>(), as appropriate.</p>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Note">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Note]" src="../stylesheet/note.png" /></td>

            <th align="left" rowspan="1" colspan="1">Note</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>If PCRE_DUPNAMES is set and there are duplicate
              names, the behaviour may not be what you want (see
              the next section).</p>
            </td>
          </tr>
        </table>
      </div>

      <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Warning]" src="../stylesheet/warning.png" /></td>

            <th align="left" rowspan="1" colspan="1">Warning</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>If the pattern uses the (?| feature to set up
              multiple subpatterns with the same number, as
              described in the section on duplicate subpattern
              numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
              page, you cannot use names to distinguish the
              different subpatterns, because names are not included
              in the compiled code. The matching process uses only
              numbers. For this reason, the use of different names
              for subpatterns of the same number causes an error at
              compile time.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="refsect1" title="DUPLICATE SUBPATTERN NAMES">
      <a id="pcreapi-3_sect22" name="pcreapi-3_sect22" shape="rect"> </a>

      <h2>DUPLICATE SUBPATTERN NAMES</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_get_stringtable_entries</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">first</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">last</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>When a pattern is compiled with the PCRE_DUPNAMES option,
      names for subpatterns are not required to be unique.
      (Duplicate names are always allowed for subpatterns with the
      same number, created by using the (?| feature. Indeed, if
      such subpatterns are named, they are required to use the same
      names.)</p>

      <p>Normally, patterns with duplicate names are such that in
      any one match, only one of the named subpatterns
      participates. An example is shown in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation.</p>

      <p>When duplicates are present, <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>()
      return the first substring corresponding to the given name
      that is set. If none are set, PCRE_ERROR_NOSUBSTRING (-7) is
      returned; no data is returned. The <code class="function">pcre_get_stringnumber</code>() function returns
      one of the numbers that are associated with the name, but it
      is not defined which it is.</p>

      <p>If you want to get full details of all captured substrings
      for a given name, you must use the <code class="function">pcre_get_stringtable_entries</code>() function.
      The first argument is the compiled pattern, and the second is
      the name. The third and fourth are pointers to variables
      which are updated by the function. After it has run, they
      point to the first and last entries in the name-to-number
      table for the given name. The function itself returns the
      length of each entry, or PCRE_ERROR_NOSUBSTRING (-7) if there
      are none. The format of the table is described above in the
      section entitled <span class="emphasis"><em>Information about
      a pattern</em></span>. Given all the relevant entries for the
      name, you can extract each of their numbers, and hence the
      captured data, if any.</p>
    </div>

    <div class="refsect1" title="FINDING ALL POSSIBLE MATCHES">
      <a id="pcreapi-3_sect23" name="pcreapi-3_sect23" shape="rect"> </a>

      <h2>FINDING ALL POSSIBLE MATCHES</h2>

      <p>The traditional matching function uses a similar algorithm
      to Perl, which stops when it finds the first match, starting
      at a given point in the subject. If you want to find all
      possible matches, or the longest possible match, consider
      using the alternative matching function (see below) instead.
      If you cannot use the alternative function, but still need to
      find all possible matches, you can kludge it up by making use
      of the callout facility, which is described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>

      <p>What you have to do is to insert a callout right at the
      end of the pattern. When your callout function is called,
      extract and save the current matched substring. Then return
      1, which forces <code class="function">pcre_exec</code>() to
      backtrack and try other alternatives. Ultimately, when it
      runs out of matches, <code class="function">pcre_exec</code>() will yield
      PCRE_ERROR_NOMATCH.</p>
    </div>

    <div class="refsect1" title="MATCHING A PATTERN: THE ALTERNATIVE FUNCTION">
      <a id="pcreapi-3_sect24" name="pcreapi-3_sect24" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int <b class="fsfunc">pcre_dfa_exec</b>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">workspace</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">wscount</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_dfa_exec</code>()
      is called to match a subject string against a compiled
      pattern, using a matching algorithm that scans the subject
      string just once, and does not backtrack. This has different
      characteristics to the normal algorithm, and is not
      compatible with Perl. Some of the features of PCRE patterns
      are not supported. Nevertheless, there are times when this
      kind of matching can be useful. For a discussion of the two
      matching algorithms, and a list of features that <code class="function">pcre_dfa_exec</code>() does not support, see the
      <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>The arguments for the <code class="function">pcre_dfa_exec</code>() function are the same as
      for <code class="function">pcre_exec</code>(), plus two
      extras. The <em class="parameter"><code>ovector</code></em>
      argument is used in a different way, and this is described
      below. The other common arguments are used in the same way as
      for <code class="function">pcre_exec</code>(), so their
      description is not repeated here.</p>

      <p>The two additional arguments provide workspace for the
      function. The workspace vector should contain at least 20
      elements. It is used for keeping track of multiple paths
      through the pattern tree. More workspace will be needed for
      patterns and subjects where there are a lot of potential
      matches.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_dfa_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[10];
 int wspace[20];
 rc = pcre_dfa_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   10,             /* number of elements (NOT size in bytes) */
   wspace,         /* working space vector */
   20);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2" title="Option bits for pcre_dfa_exec()">
        <a id="pcreapi-3_sect25" name="pcreapi-3_sect25" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_dfa_exec</code>() must be zero.
        The only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_UTF8_CHECK,
        PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE,
        PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST,
        and PCRE_DFA_RESTART. All but the last four of these are
        exactly the same as for <code class="function">pcre_exec</code>(), so their description is not
        repeated here.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These have the same general effect as they do for
        <code class="function">pcre_exec</code>(), but the details
        are slightly different. When PCRE_PARTIAL_HARD is set for
        <code class="function">pcre_dfa_exec</code>(), it returns
        PCRE_ERROR_PARTIAL if the end of the subject is reached and
        there is still at least one matching possibility that
        requires additional characters. This happens even if some
        complete matches have also been found. When
        PCRE_PARTIAL_SOFT is set, the return code
        PCRE_ERROR_NOMATCH is converted into PCRE_ERROR_PARTIAL if
        the end of the subject is reached, there have been no
        complete matches, but there is still at least one matching
        possibility. The portion of the string that was inspected
        when the longest partial match was found is set as the
        first matching string in both cases. There is a more
        detailed discussion of partial and multi-segment matching,
        with examples, in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_DFA_SHORTEST</code></span></dt>

            <dd>
              <p>Setting the PCRE_DFA_SHORTEST option causes the
              matching algorithm to stop as soon as it has found
              one match. Because of the way the alternative
              algorithm works, this is necessarily the shortest
              possible match at the first possible matching point
              in the subject string.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_DFA_RESTART</code></span></dt>

            <dd>
              <p>When <code class="function">pcre_dfa_exec</code>()
              returns a partial match, it is possible to call it
              again, with additional subject characters, and have
              it continue with the same match. The PCRE_DFA_RESTART
              option requests this action; when it is set, the
              <em class="parameter"><code>workspace</code></em> and
              <em class="parameter"><code>wscount</code></em>
              options must reference the same vector as before
              because data about the match so far is left in them
              after a partial match. There is more discussion of
              this facility in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
              documentation.</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="refsect2" title="Successful returns from pcre_dfa_exec()">
        <a id="pcreapi-3_sect26" name="pcreapi-3_sect26" shape="rect"> </a>

        <h3>Successful returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>When <code class="function">pcre_dfa_exec</code>()
        succeeds, it may have matched more than one substring in
        the subject. Note, however, that all the matches from one
        run of the function start at the same point in the subject.
        The shorter matches are all initial substrings of the
        longer matches. For example, if the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
&lt;.*&gt;
</pre>
        </div>

        <p>is matched against the string</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
This is &lt;something&gt; &lt;something else&gt; &lt;something further&gt; no more
</pre>
        </div>

        <p>the three matched strings are</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 &lt;something&gt;
 &lt;something&gt; &lt;something else&gt;
 &lt;something&gt; &lt;something else&gt; &lt;something further&gt;
</pre>
        </div>

        <p>On success, the yield of the function is a number
        greater than zero, which is the number of matched
        substrings. The substrings themselves are returned in
        <em class="parameter"><code>ovector</code></em>. Each
        string uses two elements; the first is the offset to the
        start, and the second is the offset to the end. In fact,
        all the strings have the same start offset. (Space could
        have been saved by giving this only once, but it was
        decided to retain some compatibility with the way
        <code class="function">pcre_exec</code>() returns data,
        even though the meaning of the strings is different.)</p>

        <p>The strings are returned in reverse order of length;
        that is, the longest matching string is given first. If
        there were too many matches to fit into <em class="parameter"><code>ovector</code></em>, the yield of the
        function is zero, and the vector is filled with the longest
        matches.</p>
      </div>

      <div class="refsect2" title="Error returns from pcre_dfa_exec()">
        <a id="pcreapi-3_sect27" name="pcreapi-3_sect27" shape="rect"> </a>

        <h3>Error returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The <code class="function">pcre_dfa_exec</code>()
        function returns a negative number when it fails. Many of
        the errors are the same as for <code class="function">pcre_exec</code>(), and these are described
        above. There are in addition the following errors that are
        specific to <code class="function">pcre_dfa_exec</code>():</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UITEM      (-16)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters an item in the
        pattern that it does not support, for instance, the use of
        \C or a back reference.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UCOND      (-17)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters a condition
        item that uses a back reference for the condition, or a
        test for recursion in a specific group. These are not
        supported.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UMLIMIT    (-18)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() is called with an
        <em class="parameter"><code>extra</code></em> block that
        contains a setting of the <em class="parameter"><code>match_limit</code></em> field. This is
        not supported (it is meaningless).</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_WSSIZE     (-19)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() runs out of space in the
        <em class="parameter"><code>workspace</code></em>
        vector.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_RECURSE    (-20)
</pre>
        </div>

        <p>When a recursive subpattern is processed, the matching
        function calls itself recursively, using private vectors
        for <em class="parameter"><code>ovector</code></em> and
        <em class="parameter"><code>workspace</code></em>. This
        error is given if the output vector is not large enough.
        This should be extremely rare, as a vector of size 1000 is
        used.</p>
      </div>
    </div>

    <div class="refsect1" title="SEE ALSO">
      <a id="pcreapi-3_sect28" name="pcreapi-3_sect28" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>,
      <span class="citerefentry"><span class="refentrytitle">pcrecpp(3)</span>(3)</span>, <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>,
      <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>.</p>
    </div>

    <div class="refsect1" title="AUTHOR">
      <a id="pcreapi-3_sect29" name="pcreapi-3_sect29" shape="rect"> </a>

      <h2>AUTHOR</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</pre>
      </div>
    </div>

    <div class="refsect1" title="REVISION">
      <a id="pcreapi-3_sect30" name="pcreapi-3_sect30" shape="rect"> </a>

      <h2>REVISION</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Last updated: 21 November 2010
Copyright (c) 1997-2010 University of Cambridge.
</pre>
      </div>

      <div class="license">
        <table style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>

          <thead>
            <tr>
              <th style="" rowspan="1" colspan="1">COPYRIGHT</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <p>This manual page is taken from the <a class="ulink" href="http://www.PCRE.org/" target="_top" shape="rect">PCRE library</a>, which is distributed under
                the BSD license.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
